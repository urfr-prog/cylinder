<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ADAM - Puzzle Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; touch-action: none; }
        body {
            background-color: #12131a;
            min-height: 100vh; min-height: -webkit-fill-available;
            display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .logo { display: flex; align-items: center; gap: 4px; height: 40px; margin-top: -30px; cursor: pointer; }
        .logo-icon { width: 36px; height: 36px; }
        .logo-icon svg { width: 100%; height: 100%; }
        .logo-icon svg path, .logo-icon svg line, .logo-icon svg rect, .logo-icon svg polygon {
            stroke: rgba(240, 240, 250, 0.9); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; fill: none;
            filter: drop-shadow(0 0 8px rgba(240, 240, 250, 0.4));
        }
        
        /* Barre de score compacte avec inputs */
        .score-bar {
            display: flex; align-items: center; justify-content: space-between; gap: 8px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(180, 180, 190, 0.2);
            border-radius: 12px; padding: 6px 12px; 
            width: calc(var(--cell) * 4 + var(--gap) * 3);
        }
        .score-item { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .score-item.compact { flex-direction: row; gap: 4px; align-items: center; }
        .score-item.with-input { flex-direction: column; gap: 2px; }
        .score-label { font-size: 0.6rem; color: rgba(180, 180, 190, 0.5); text-transform: uppercase; letter-spacing: 0.05em; }
        .score-value { font-size: 1rem; color: rgba(220, 220, 230, 0.9); font-weight: 500; font-variant-numeric: tabular-nums; }
        .score-value.small { font-size: 0.85rem; }
        .score-value.highlight { animation: scoreFlash 0.5s ease-out; }
        @keyframes scoreFlash { 0% { color: #ffd700; transform: scale(1.2); } 100% { color: rgba(220, 220, 230, 0.9); transform: scale(1); } }
        .combo { color: #34d399 !important; }
        .combo-label { color: #34d399 !important; }
        .stat-icon { font-size: 0.8rem; filter: drop-shadow(0 0 2px currentColor); }
        .stat-icon { font-size: 0.8rem; filter: drop-shadow(0 0 2px currentColor); }
        
        /* Bouton toggle animation points */
        .points-toggle {
            width: 28px; height: 28px; border-radius: 6px; border: 1px solid rgba(34, 211, 238, 0.4);
            background: rgba(34, 211, 238, 0.1); color: rgba(34, 211, 238, 0.6);
            font-size: 0.9rem; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; padding: 0;
        }
        .points-toggle:hover { border-color: rgba(34, 211, 238, 0.7); background: rgba(34, 211, 238, 0.2); }
        .points-toggle.active { 
            border-color: #22d3ee; background: rgba(34, 211, 238, 0.3); color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.4);
        }
        
        /* Conteneur pour grid et layer */
        .game-container {
            position: relative;
            width: calc(var(--cell) * 4 + var(--gap) * 3);
            height: calc(var(--cell) * 6 + var(--gap) * 5);
        }
        
        /* Layer menu concepteur - positionn√© au-dessus de la grille */
        .settings-layer {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(34, 211, 238, 0.5);
            border-radius: 12px;
            z-index: 100;
        }
        .settings-layer.active {
            display: block;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(4, var(--cell));
            grid-template-rows: repeat(6, var(--cell));
            gap: var(--gap); --cell: min(80px, 20vw); --gap: 8px;
        }
        .cell { width: var(--cell); height: var(--cell); position: relative; }
        .square {
            width: 100%; height: 100%; background-color: transparent;
            border: 1px solid rgba(180, 180, 190, 0.35); border-radius: 12px;
            position: absolute; top: 0; left: 0; overflow: hidden; cursor: pointer;
        }
        .square:hover { border-color: rgba(180, 180, 190, 0.6); }
        .square.empty { border-style: dashed; border-color: rgba(180, 180, 190, 0.2); cursor: default; }
        .square.empty:hover { border-color: rgba(180, 180, 190, 0.3); }
        .square svg { width: 100%; height: 100%; }
        svg .separator { stroke-width: 1; }
        svg line.icon, svg path.icon, svg circle.icon, svg rect.icon { stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; fill: none; }
        
        /* BLANC - ic√¥nes m√™me intensit√© que les lignes */
        .square.white { border-color: rgba(180, 180, 190, 0.35); }
        .square.white svg line.icon, .square.white svg path.icon, .square.white svg circle.icon, .square.white svg rect.icon { stroke: rgba(180, 180, 190, 0.35); }
        .square.white svg circle.point { fill: rgba(180, 180, 190, 0.35); }
        .square.white svg .separator { stroke: rgba(180, 180, 190, 0.3); }
        
        /* ARGENT - cyan subtil (ancien diamant mais moins intense) */
        .square.silver { border-color: rgba(6, 182, 212, 0.6); box-shadow: 0 0 12px rgba(6, 182, 212, 0.2), inset 0 0 15px rgba(6, 182, 212, 0.05); }
        .square.silver svg line.icon, .square.silver svg path.icon, .square.silver svg circle.icon, .square.silver svg rect.icon { stroke: #22d3ee; filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); }
        .square.silver svg circle.point { fill: #22d3ee; filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); }
        .square.silver svg .separator { stroke: rgba(34, 211, 238, 0.4); }
        
        /* OR */
        .square.gold { border-color: rgba(255, 215, 0, 0.7); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3), inset 0 0 20px rgba(255, 215, 0, 0.05); }
        .square.gold svg line.icon, .square.gold svg path.icon, .square.gold svg circle.icon, .square.gold svg rect.icon { stroke: #ffd700; filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); }
        .square.gold svg circle.point { fill: #ffd700; filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); }
        .square.gold svg .separator { stroke: rgba(255, 215, 0, 0.4); }
        
        /* √âMERAUDE */
        .square.emerald { border-color: rgba(52, 211, 153, 0.9); box-shadow: 0 0 25px rgba(5, 150, 105, 0.5), 0 0 40px rgba(52, 211, 153, 0.3), inset 0 0 25px rgba(52, 211, 153, 0.1); animation: emeraldGlow 2.5s ease-in-out infinite; }
        .square.emerald svg line.icon, .square.emerald svg path.icon, .square.emerald svg circle.icon, .square.emerald svg rect.icon { stroke: #34d399; filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)) drop-shadow(0 0 12px rgba(5, 150, 105, 0.5)); }
        .square.emerald svg circle.point { fill: #34d399; filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)); }
        .square.emerald svg .separator { stroke: rgba(52, 211, 153, 0.6); }
        @keyframes emeraldGlow {
            0%, 100% { box-shadow: 0 0 25px rgba(5, 150, 105, 0.5), 0 0 40px rgba(52, 211, 153, 0.3), inset 0 0 25px rgba(52, 211, 153, 0.1); }
            50% { box-shadow: 0 0 35px rgba(5, 150, 105, 0.7), 0 0 55px rgba(52, 211, 153, 0.4), inset 0 0 35px rgba(52, 211, 153, 0.15); }
        }
        
        /* COSMIC - Halo mod√©r√© */
        .square.cosmic { border: 2px solid transparent; background: linear-gradient(#12131a, #12131a) padding-box, conic-gradient(from var(--cosmic-angle, 0deg), #ff006e, #8338ec, #06b6d4, #34d399, #ffd700, #ff006e) border-box; box-shadow: 0 0 25px rgba(131, 56, 236, 0.4), 0 0 40px rgba(255, 0, 110, 0.2), 0 0 50px rgba(6, 182, 212, 0.2), inset 0 0 30px rgba(131, 56, 236, 0.1); animation: cosmicRotate 4s linear infinite, cosmicPulse 2s ease-in-out infinite; }
        .square.cosmic svg line.icon, .square.cosmic svg path.icon, .square.cosmic svg circle.icon, .square.cosmic svg rect.icon { stroke: #c4b5fd; filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)) drop-shadow(0 0 10px rgba(255, 0, 110, 0.4)); animation: cosmicIconShift 3s ease-in-out infinite; }
        .square.cosmic svg circle.point { fill: #c4b5fd; filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)); animation: cosmicPointPulse 1.5s ease-in-out infinite; }
        .square.cosmic svg .separator { stroke: rgba(196, 181, 253, 0.6); }
        @property --cosmic-angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes cosmicRotate { to { --cosmic-angle: 360deg; } }
        @keyframes cosmicPulse {
            0%, 100% { box-shadow: 0 0 25px rgba(131, 56, 236, 0.4), 0 0 40px rgba(255, 0, 110, 0.2), 0 0 50px rgba(6, 182, 212, 0.2), inset 0 0 30px rgba(131, 56, 236, 0.1); }
            50% { box-shadow: 0 0 35px rgba(131, 56, 236, 0.6), 0 0 55px rgba(255, 0, 110, 0.35), 0 0 70px rgba(6, 182, 212, 0.3), inset 0 0 40px rgba(131, 56, 236, 0.15); }
        }
        @keyframes cosmicIconShift { 0%, 100% { stroke: #c4b5fd; } 33% { stroke: #22d3ee; } 66% { stroke: #f472b6; } }
        @keyframes cosmicPointPulse { 0%, 100% { fill: #c4b5fd; } 50% { fill: #f472b6; } }
        
        /* SUPERNOVAE - Surface solaire en fusion */
        .square.supernovae { border: 3px solid transparent; background: linear-gradient(#12131a, #12131a) padding-box, conic-gradient(from var(--supernova-angle, 0deg), #ff4500, #ff8c00, #ffd700, #ffff00, #ff8c00, #ff4500) border-box; box-shadow: 0 0 25px rgba(255, 140, 0, 0.4), 0 0 40px rgba(255, 69, 0, 0.2), 0 0 50px rgba(255, 215, 0, 0.2), inset 0 0 30px rgba(255, 140, 0, 0.1); animation: supernovaRotate 3s linear infinite, supernovaPulse 1.5s ease-in-out infinite; }
        .square.supernovae svg line.icon, .square.supernovae svg path.icon, .square.supernovae svg circle.icon, .square.supernovae svg rect.icon { stroke: #ffeb3b; filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7)) drop-shadow(0 0 10px rgba(255, 140, 0, 0.4)); animation: supernovaIconShift 2.5s ease-in-out infinite; }
        .square.supernovae svg circle.point { fill: #ffeb3b; filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7)); animation: supernovaPointPulse 1.2s ease-in-out infinite; }
        .square.supernovae svg .separator { stroke: rgba(255, 235, 59, 0.6); }
        @property --supernova-angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes supernovaRotate { to { --supernova-angle: 360deg; } }
        @keyframes supernovaPulse {
            0%, 100% { box-shadow: 0 0 25px rgba(255, 140, 0, 0.4), 0 0 40px rgba(255, 69, 0, 0.2), 0 0 50px rgba(255, 215, 0, 0.2), inset 0 0 30px rgba(255, 140, 0, 0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 140, 0, 0.6), 0 0 55px rgba(255, 69, 0, 0.35), 0 0 70px rgba(255, 215, 0, 0.3), inset 0 0 40px rgba(255, 140, 0, 0.15); }
        }
        @keyframes supernovaIconShift { 
            0%, 100% { stroke: #ffeb3b; } 
            25% { stroke: #ff8c00; } 
            50% { stroke: #ffd700; } 
            75% { stroke: #ff6347; } 
        }
        @keyframes supernovaPointPulse { 
            0%, 100% { fill: #ffeb3b; } 
            33% { fill: #ff8c00; } 
            66% { fill: #ffd700; } 
        }
        
        .square.fusing { transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease; }
        
        .controls { display: flex; gap: 8px; width: calc(var(--cell) * 4 + var(--gap) * 3); justify-content: space-between; }
        .level-selector { display: flex; gap: 8px; }
        .level-btn {
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
            background: transparent; border: 1px solid rgba(180, 180, 190, 0.35); color: rgba(180, 180, 190, 0.6);
            border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.2s;
        }
        .level-btn:hover { border-color: rgba(180, 180, 190, 0.6); color: rgba(220, 220, 230, 0.9); }
        .level-btn.active { border-color: rgba(34, 211, 153, 0.7); color: #34d399; box-shadow: 0 0 10px rgba(34, 211, 153, 0.3); }
        
        /* Panneau de notes */
        .notes-panel {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(18, 19, 26, 0.95); backdrop-filter: blur(10px);
            display: none; align-items: center; justify-content: center; z-index: 2000;
        }
        .notes-panel.active { display: flex; }
        .notes-content {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(180, 180, 190, 0.3);
            border-radius: 16px; padding: 24px; max-width: 90%; max-height: 80vh; overflow-y: auto;
            color: rgba(220, 220, 230, 0.9);
        }
        .notes-content h2 { color: #22d3ee; margin-bottom: 16px; font-size: 1.2rem; }
        .notes-content h3 { color: rgba(220, 220, 230, 0.8); margin: 16px 0 8px 0; font-size: 1rem; }
        .notes-content pre { 
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; 
            overflow-x: auto; font-family: monospace; font-size: 0.85rem; line-height: 1.6;
        }
        .notes-content p { line-height: 1.6; margin: 8px 0; color: rgba(180, 180, 190, 0.9); }
        .close-notes {
            margin-top: 16px; width: 100%; padding: 10px;
            background: transparent; border: 1px solid rgba(180, 180, 190, 0.35);
            color: rgba(180, 180, 190, 0.7); border-radius: 8px; cursor: pointer;
        }
        .close-notes:hover { border-color: #22d3ee; color: #22d3ee; }
        
        button {
            background: transparent; border: 1px solid rgba(180, 180, 190, 0.35); color: rgba(180, 180, 190, 0.7);
            padding: 8px 14px; border-radius: 8px; cursor: pointer; font-size: 0.75rem; letter-spacing: 0.05em; transition: all 0.2s;
        }
        button:hover { border-color: rgba(180, 180, 190, 0.6); color: rgba(220, 220, 230, 0.9); }
        
        /* Points flottants */
        .floating-points {
            position: fixed; pointer-events: none; font-size: 1.2rem; font-weight: bold;
            color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            animation: floatUp 1s ease-out forwards; z-index: 1000;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
        }
    </style>
</head>
<body>
    <div class="logo">
        <div class="logo-icon"><svg viewBox="0 0 36 36"><path d="M8 26L18 10L28 26"/></svg></div>
        <div class="logo-icon"><svg viewBox="0 0 36 36"><polygon points="10,10 26,18 10,26"/></svg></div>
        <div class="logo-icon"><svg viewBox="0 0 36 36"><path d="M8 26L18 10L28 26"/></svg></div>
        <div class="logo-icon"><svg viewBox="0 0 36 36"><line x1="10" y1="8" x2="10" y2="28"/><line x1="18" y1="8" x2="18" y2="28"/><line x1="26" y1="8" x2="26" y2="28"/></svg></div>
    </div>
    
    <div class="game-container">
        <!-- Layer menu concepteur -->
        <div class="settings-layer" id="settings-layer">
            <div style="display: flex; flex-direction: column; gap: 12px; padding: 12px; align-items: center;">
                <!-- Ligne 1: Bouton animation + compteurs fusion -->
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button id="points-anim-toggle" class="points-toggle" title="Animation des points">‚ú®</button>
                    <button id="twin-toggle" class="points-toggle" title="Fusions Jumeaux">üëØ</button>
                    
                    <div style="display: flex; gap: 4px; align-items: center;">
                        <span class="stat-icon" style="color: #22d3ee;">üíé</span>
                        <span class="score-value small" id="silver-count">0</span>
                    </div>
                    
                    <div style="display: flex; gap: 4px; align-items: center;">
                        <span class="stat-icon" style="color: #ffd700;">üèÜ</span>
                        <span class="score-value small" id="gold-count">0</span>
                    </div>
                    
                    <div style="display: flex; gap: 4px; align-items: center;">
                        <span class="stat-icon" style="color: #34d399;">üíö</span>
                        <span class="score-value small" id="emerald-count">0</span>
                    </div>
                    
                    <div style="display: flex; gap: 4px; align-items: center;">
                        <span class="stat-icon" style="color: #c4b5fd;">üåü</span>
                        <span class="score-value small" id="cosmic-count">0</span>
                    </div>
                    
                    <div style="display: flex; gap: 4px; align-items: center;">
                        <span class="stat-icon" style="color: #ff8c00;">‚òÄÔ∏è</span>
                        <span class="score-value small" id="supernovae-count">0</span>
                    </div>
                </div>
                
                <!-- Ligne 2: Boutons niveau + Undo + Note -->
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button class="level-btn active" onclick="setLevel(1)">1</button>
                    <button class="level-btn" onclick="setLevel(2)">2</button>
                    <button class="level-btn" onclick="setLevel(3)">3</button>
                    <button class="level-btn" onclick="setLevel(4)">4</button>
                    <button onclick="undo()">Undo</button>
                    <button onclick="toggleNotes()">Note</button>
                </div>
            </div>
        </div>
        
        <div class="grid" id="grid"></div>
    </div>
    
    <div class="score-bar">
        <div class="score-item">
            <span class="score-label">Score</span>
            <span class="score-value" id="score">0</span>
        </div>
        
        <div class="score-item">
            <span class="score-label combo-label">Combo</span>
            <span class="score-value combo" id="combo">√ó1</span>
        </div>
        
        <div class="score-item">
            <span class="score-label">Best</span>
            <span class="score-value" id="best">0</span>
        </div>
    </div>
    
    <!-- Panneau de notes -->
    <div class="notes-panel" id="notes-panel">
        <div class="notes-content">
            <h2>üìù Notes & Conventions</h2>
            
            <h3>Convention de num√©rotation de la grille :</h3>
            <p>Les dominos sont num√©rot√©s de gauche √† droite, de bas en haut :</p>
            <pre>
21  22  23  24    ‚Üê Ligne 6 (haut)
17  18  19  20    ‚Üê Ligne 5
13  14  15  16    ‚Üê Ligne 4
9   10  11  12    ‚Üê Ligne 3
5   6   7   8     ‚Üê Ligne 2
1   2   3   4     ‚Üê Ligne 1 (bas)
            </pre>
            
            <h3>Syst√®me de chute des dominos :</h3>
            <p>Apr√®s une fusion, de nouveaux dominos peuvent tomber selon les r√©glages (inputs dans le bandeau).</p>
            <p><strong>D√©lai avant chute :</strong> 500ms apr√®s la fin de la gravit√© du plateau</p>
            <p><strong>Vitesse de chute :</strong> 400ms entre chaque domino qui appara√Æt</p>
            <p>Les dominos suivent la s√©quence du niveau en boucle (positions 1-24) et conservent leur orientation d'origine.</p>
            
            <h3>Niveaux :</h3>
            <p>Chaque niveau (1, 2, 3, 4) g√©n√®re une grille unique avec une s√©quence pr√©d√©finie. Cliquer sur un niveau pendant le jeu r√©initialise la partie avec ce niveau.</p>
            
            <button class="close-notes" onclick="toggleNotes()">Fermer</button>
        </div>
    </div>
    
    <script>
        const COLS = 4, ROWS = 6, TOTAL = 24;
        const STATE_ORDER = ['white', 'silver', 'gold', 'emerald', 'cosmic', 'supernovae'];
        const STATE_MULTIPLIER = { white: 1, silver: 2, gold: 3, emerald: 5, cosmic: 10, supernovae: 20 };
        const POINTS = { simple: 100, chain: 500, twin: 1000 };
        const ROTATION_SPEED = 800;
        const FUSION_MOVE = 400, FUSION_FADE = 200, FUSION_APPEAR = 500, GRAVITY_DELAY = 150;
        const MAX_HISTORY = 20;
        
        let showPointsAnimation = true; // Toggle pour l'animation des points
        let enableTwinFusion = false; // Toggle pour les fusions jumeaux (off par d√©faut)
        
        const ICONS = {
            // Sigles niveau 1, 3, 4 (originaux)
            chevron: { f1: 'M20 32L45 12L70 32', f2: 'M20 12L45 32L70 12', t: 'path' },
            circle: { f1: '45,22,12', f2: '45,22,12', t: 'circle' },
            twoCircles: { f1: '30,22,8|60,22,8', f2: '30,22,8|60,22,8', t: 'circles' },
            line: { f1: '15,22,75,22', f2: '15,22,75,22', t: 'line' },
            threeLines: { f1: '25,10,25,34|45,10,45,34|65,10,65,34', f2: '25,10,25,34|45,10,45,34|65,10,65,34', t: 'lines' },
            twoPoints: { f1: '30,22,4|60,22,4', f2: '30,22,4|60,22,4', t: 'points' },
            square: { f1: '25,10,40,24,3', f2: '25,10,40,24,3', t: 'rect' },
            wave: { f1: 'M10 22Q28 6 45 22Q62 38 80 22', f2: 'M10 22Q28 6 45 22Q62 38 80 22', t: 'path' },
            
            // Nouveaux sigles niveau 2
            twoL: { f1: 'M15 10L15 22L27 22', f2: 'M75 10L75 22L63 22', t: 'path' },
            arc: { f1: 'M20 30Q45 8 70 30', f2: 'M20 14Q45 36 70 14', t: 'path' },
            twoSquares: { f1: '24,14,12,12,2|54,14,12,12,2', f2: '24,14,12,12,2|54,14,12,12,2', t: 'rects' },
            target: { f1: '45,22,12|45,22,4', f2: '45,22,12|45,22,4', t: 'target' },
            dumbbell: { f1: '30,22,5|60,22,5|30,22,60,22', f2: '30,22,5|60,22,5|30,22,60,22', t: 'dumbbell' },
            singleLine: { f1: '45,10,45,34', f2: '45,10,45,34', t: 'line' },
            singlePoint: { f1: '45,22,5', f2: '45,22,5', t: 'circle' },
            diamond: { f1: 'M45 10L60 22L45 34L30 22Z', f2: 'M45 10L60 22L45 34L30 22Z', t: 'path' },
            
            // Nouveaux sigles niveau 3 (difficile)
            cross: { f1: 'M45 8L45 36M29 22L61 22', f2: 'M45 8L45 36M29 22L61 22', t: 'path' },
            triangle: { f1: 'M45 10L65 34L25 34Z', f2: 'M45 34L65 10L25 10Z', t: 'path' },
            zigzag: { f1: 'M15 30L30 14L45 30L60 14L75 30', f2: 'M15 14L30 30L45 14L60 30L75 14', t: 'path' },
            brackets: { f1: 'M30 10L20 10L20 34L30 34', f2: 'M60 10L70 10L70 34L60 34', t: 'path' },
            threePoints: { f1: '30,22,4|45,22,4|60,22,4', f2: '30,22,4|45,22,4|60,22,4', t: 'points' },
            halfCircle: { f1: 'M30 30A15 15 0 0 1 60 30', f2: 'M30 14A15 15 0 0 0 60 14', t: 'path' },
            arrow: { f1: 'M20 22L70 22M55 12L70 22L55 32', f2: 'M70 22L20 22M35 12L20 22L35 32', t: 'path' },
            hexagon: { f1: 'M35 10L55 10L65 22L55 34L35 34L25 22Z', f2: 'M35 10L55 10L65 22L55 34L35 34L25 22Z', t: 'path' },
            
            // Nouveaux sigles niveau 4 (difficile, petits)
            miniDot: { f1: '45,22,3', f2: '45,22,3', t: 'circle' },
            twoDots: { f1: '38,22,3|52,22,3', f2: '38,22,3|52,22,3', t: 'points' },
            miniCross: { f1: 'M45 16L45 28M39 22L51 22', f2: 'M45 16L45 28M39 22L51 22', t: 'path' },
            miniSquare: { f1: '38,15,14,14,2', f2: '38,15,14,14,2', t: 'rect' },
            miniTriangle: { f1: 'M45 14L54 30L36 30Z', f2: 'M45 30L54 14L36 14Z', t: 'path' },
            slash: { f1: 'M35 30L55 14', f2: 'M35 14L55 30', t: 'path' },
            miniV: { f1: 'M35 14L45 28L55 14', f2: 'M35 30L45 16L55 30', t: 'path' },
            fourDots: { f1: '38,16,2|52,16,2|38,28,2|52,28,2', f2: '38,16,2|52,16,2|38,28,2|52,28,2', t: 'points' }
        };
        
        // Sets d'ic√¥nes par niveau
        const LEVEL_ICON_SETS = {
            1: ['chevron', 'circle', 'twoCircles', 'line', 'threeLines', 'twoPoints', 'square', 'wave'],
            2: ['twoL', 'arc', 'twoSquares', 'target', 'dumbbell', 'singleLine', 'singlePoint', 'diamond'],
            3: ['cross', 'triangle', 'zigzag', 'brackets', 'threePoints', 'halfCircle', 'arrow', 'hexagon'],
            4: ['miniDot', 'twoDots', 'miniCross', 'miniSquare', 'miniTriangle', 'slash', 'miniV', 'fourDots']
        };
        
        function getIconKeysForLevel(level) {
            return LEVEL_ICON_SETS[level] || LEVEL_ICON_SETS[1];
        }
        
        let dominos = [], grid = document.getElementById('grid');
        let isAnimating = false, isLocalRotating = false;
        let continuousState = null, continuousTimer = null, dragState = null, history = [], scoreHistory = [];
        let rotationQueue = [];
        let score = 0, bestScore = 0, comboCount = 0, lastFusionTime = 0;
        let currentLevel = 1;
        let fusionCounts = { silver: 0, gold: 0, emerald: 0, cosmic: 0, supernovae: 0 };
        let dropSettings = { silver: 0, gold: 1, emerald: 2, cosmic: 0 };
        let dominoSequenceIndex = 1; // Compteur circulaire 1-24 pour les dominos qui tombent
        
        // Configurations des 4 niveaux (disposition initiale diff√©rente)
        const LEVEL_SEEDS = {
            1: 12345,  // Niveau 1 - Seed al√©atoire
            2: 67890,  // Niveau 2 - Seed al√©atoire diff√©rent
            3: 77777,  // Niveau 3 - Seed pour config difficile
            4: 99991   // Niveau 4 - Seed pour config tr√®s difficile
        };
        
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 1103515245 + 12345) & 0x7fffffff;
                return state / 0x7fffffff;
            };
        }
        
        // G√©n√®re le domino √† la position N (1-24) de la s√©quence du niveau actuel
        function getDominoFromSequence(position) {
            const rng = seededRandom(LEVEL_SEEDS[currentLevel]);
            const iconKeys = getIconKeysForLevel(currentLevel);
            // Avancer le g√©n√©rateur jusqu'√† la position demand√©e (position 1 = index 0)
            for (let i = 0; i < position; i++) {
                rng(); rng(); // 2 appels pour face1 et face2
            }
            const x = (position - 1) % COLS;
            const y = Math.floor((position - 1) / COLS);
            return { 
                face1: iconKeys[Math.floor(rng() * iconKeys.length)], 
                face2: iconKeys[Math.floor(rng() * iconKeys.length)], 
                rotation: ((x + y) % 2 === 0) ? 0 : 90, 
                state: 'white' 
            };
        }
        
        // Fait tomber N dominos depuis le haut de la grille, un par un avec d√©lai
        function dropNewDominos(count) {
            if (count === 0) return;
            
            isAnimating = true; // Bloquer pendant le drop
            let droppedCount = 0;
            
            function dropOne() {
                if (droppedCount >= count) {
                    // Tous les dominos sont dropp√©s, appliquer la gravit√©
                    isAnimating = false;
                    applyGravity();
                    return;
                }
                
                // Trouver une colonne disponible en haut (ligne 0)
                const availableColumns = [];
                for (let x = 0; x < COLS; x++) {
                    const topIndex = getIndex(x, 0);
                    if (!dominos[topIndex]) availableColumns.push(x);
                }
                
                if (availableColumns.length === 0) {
                    // Pas de place, terminer proprement
                    console.log(`Drop interrompu : ${droppedCount}/${count} dominos plac√©s. Grille pleine.`);
                    isAnimating = false;
                    // Message visuel si on n'a pas pu placer tous les dominos
                    if (droppedCount < count) {
                        console.warn(`‚ö†Ô∏è Grille pleine ! Seulement ${droppedCount}/${count} dominos ont pu √™tre plac√©s.`);
                    }
                    applyGravity();
                    return;
                }
                
                // Choisir une colonne au hasard parmi les disponibles
                const col = availableColumns[Math.floor(Math.random() * availableColumns.length)];
                const topIndex = getIndex(col, 0);
                
                // Cr√©er le domino depuis la s√©quence
                dominos[topIndex] = getDominoFromSequence(dominoSequenceIndex);
                
                // Incr√©menter et boucler 1-24
                dominoSequenceIndex++;
                if (dominoSequenceIndex > TOTAL) dominoSequenceIndex = 1;
                
                render();
                droppedCount++;
                
                // D√©lai de 250ms entre chaque domino qui tombe
                setTimeout(dropOne, 250);
            }
            
            // Commencer imm√©diatement
            dropOne();
        }

        function renderIcon(icon, isFace2) {
            const d = ICONS[icon], data = isFace2 ? d.f2 : d.f1;
            if (d.t === 'path') return `<path class="icon" d="${data}"/>`;
            if (d.t === 'circle') { const [cx,cy,r] = data.split(','); return `<circle class="icon" cx="${cx}" cy="${cy}" r="${r}"/>`; }
            if (d.t === 'line') { const [x1,y1,x2,y2] = data.split(','); return `<line class="icon" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`; }
            if (d.t === 'rect') { const [x,y,w,h,rx] = data.split(','); return `<rect class="icon" x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}"/>`; }
            
            // Deux rectangles
            if (d.t === 'rects') {
                return data.split('|').map(p => {
                    const [x,y,w,h,rx] = p.split(',');
                    return `<rect class="icon" x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}"/>`;
                }).join('');
            }
            
            // Cible (cercle ext√©rieur + point central)
            if (d.t === 'target') {
                const parts = data.split('|');
                const [cx1,cy1,r1] = parts[0].split(',');
                const [cx2,cy2,r2] = parts[1].split(',');
                return `<circle class="icon" cx="${cx1}" cy="${cy1}" r="${r1}"/><circle class="point" cx="${cx2}" cy="${cy2}" r="${r2}"/>`;
            }
            
            // Halt√®re (2 points + ligne)
            if (d.t === 'dumbbell') {
                const parts = data.split('|');
                const [cx1,cy1,r1] = parts[0].split(',');
                const [cx2,cy2,r2] = parts[1].split(',');
                const [x1,y1,x2,y2] = parts[2].split(',');
                return `<circle class="point" cx="${cx1}" cy="${cy1}" r="${r1}"/><circle class="point" cx="${cx2}" cy="${cy2}" r="${r2}"/><line class="icon" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`;
            }
            
            return data.split('|').map(p => {
                const v = p.split(',');
                return (d.t === 'circles' || d.t === 'points') 
                    ? `<circle class="${d.t === 'points' ? 'point' : 'icon'}" cx="${v[0]}" cy="${v[1]}" r="${v[2]}"/>`
                    : `<line class="icon" x1="${v[0]}" y1="${v[1]}" x2="${v[2]}" y2="${v[3]}"/>`;
            }).join('');
        }

        function renderDomino(d) {
            return `<svg viewBox="0 0 90 90"><line class="separator" x1="0" y1="45" x2="90" y2="45"/><g>${renderIcon(d.face1, false)}</g><g transform="translate(0,45)">${renderIcon(d.face2, true)}</g></svg>`;
        }

        function render() {
            grid.innerHTML = '';
            for (let i = 0; i < TOTAL; i++) {
                const cell = document.createElement('div'); cell.className = 'cell';
                const div = document.createElement('div'); div.dataset.index = i;
                if (dominos[i]) {
                    // Utiliser state1 si disponible (√©tat des faces partenaires apr√®s fusion)
                    const displayState = dominos[i].state1 || dominos[i].state;
                    div.className = `square ${displayState}`;
                    div.innerHTML = renderDomino(dominos[i]);
                    div.style.transform = `rotate(${dominos[i].rotation}deg)`;
                } else { div.className = 'square empty'; }
                cell.appendChild(div); grid.appendChild(cell);
            }
        }

        function getPos(i) { return { x: i % COLS, y: Math.floor(i / COLS) }; }
        function getIndex(x, y) { return (x < 0 || x >= COLS || y < 0 || y >= ROWS) ? -1 : y * COLS + x; }

        function getExposedFace(domino, dir) {
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = { 0: { top: 'face1', bottom: 'face2' }, 90: { left: 'face2', right: 'face1' }, 180: { top: 'face2', bottom: 'face1' }, 270: { left: 'face1', right: 'face2' } };
            const face = map[r]?.[dir]; return face ? domino[face] : null;
        }

        // Obtenir l'√©tat de la face expos√©e dans une direction
        function getExposedState(domino, dir) {
            // Si le domino a des √©tats individuels par face
            if (domino.state1 !== undefined) {
                const r = ((domino.rotation % 360) + 360) % 360;
                // D√©terminer quelle face (face1 ou face2) est expos√©e dans cette direction
                const map = { 
                    0: { top: 'state1', bottom: 'state2' }, 
                    90: { left: 'state2', right: 'state1' }, 
                    180: { top: 'state2', bottom: 'state1' }, 
                    270: { left: 'state1', right: 'state2' } 
                };
                const stateKey = map[r]?.[dir];
                return stateKey ? domino[stateKey] : domino.state1;
            }
            return domino.state;
        }

        function getRemainingFace(domino, excDir) {
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = { 0: { top: 'face2', bottom: 'face1' }, 90: { right: 'face2', left: 'face1' }, 180: { top: 'face1', bottom: 'face2' }, 270: { right: 'face1', left: 'face2' } };
            const face = map[r]?.[excDir]; return face ? domino[face] : null;
        }

        function areTwins(d1, d2) {
            if (!d1 || !d2) return false;
            
            // Les deux faces de chaque domino doivent avoir le M√äME √âTAT pour fusionner
            // Utiliser state1/state2 si disponible, sinon state
            const s1_1 = d1.state1 || d1.state;
            const s1_2 = d1.state2 || d1.state;
            const s2_1 = d2.state1 || d2.state;
            const s2_2 = d2.state2 || d2.state;
            
            // Toutes les faces doivent avoir le m√™me √©tat
            if (s1_1 !== s1_2 || s2_1 !== s2_2 || s1_1 !== s2_1) return false;
            
            const r1 = ((d1.rotation % 360) + 360) % 360;
            const r2 = ((d2.rotation % 360) + 360) % 360;
            
            // Cas 1 : M√™me rotation et m√™mes faces
            if (r1 === r2 && d1.face1 === d2.face1 && d1.face2 === d2.face2) return true;
            
            // Cas 2 : Rotation oppos√©e (180¬∞) avec faces invers√©es
            if (Math.abs(r1 - r2) === 180 && d1.face1 === d2.face2 && d1.face2 === d2.face1) return true;
            
            // Cas 3 : Rotation √† 90¬∞ ou 270¬∞ - v√©rifier si les faces correspondent apr√®s rotation
            const diff = Math.abs(r1 - r2);
            if (diff === 90 || diff === 270) {
                // √Ä 90¬∞ ou 270¬∞, face1 et face2 s'√©changent
                if (d1.face1 === d2.face2 && d1.face2 === d2.face1) return true;
            }
            
            return false;
        }

        function detectDiag(dx, dy) {
            const ax = Math.abs(dx), ay = Math.abs(dy);
            if (ax < 15 || ay < 15 || ax/ay < 0.5 || ax/ay > 2) return null;
            return dy < 0 ? (dx > 0 ? 'ur' : 'ul') : (dx > 0 ? 'dr' : 'dl');
        }

        function getGroup(x, y, dir) {
            const off = { ur: [0,-1], ul: [-1,-1], dr: [0,0], dl: [-1,0] };
            const [ox, oy] = off[dir], tx = x + ox, ty = y + oy;
            if (tx < 0 || tx > COLS-2 || ty < 0 || ty > ROWS-2) return null;
            return [getIndex(tx,ty), getIndex(tx+1,ty), getIndex(tx,ty+1), getIndex(tx+1,ty+1)];
        }

        function isClockwise(dir) { return dir === 'ur' || dir === 'dr'; }
        function stopContinuous() { if (continuousTimer) { clearTimeout(continuousTimer); continuousTimer = null; } continuousState = null; }

        function executeRotation(indices, clockwise, cb) {
            if (isLocalRotating) return;
            saveState(); isLocalRotating = true;
            const cells = indices.map(idx => ({ el: grid.children[idx].querySelector('.square'), domino: dominos[idx], sx: idx % COLS, sy: Math.floor(idx / COLS) }));
            const map = clockwise ? [2,0,3,1] : [1,3,0,2];
            cells.forEach((c, i) => { c.tx = indices[map[i]] % COLS; c.ty = Math.floor(indices[map[i]] / COLS); });
            const dur = continuousState ? ROTATION_SPEED * 0.7 : ROTATION_SPEED * 0.5;
            const start = performance.now(), cellSize = grid.children[0].offsetWidth, gap = parseFloat(getComputedStyle(grid).gap) || 8;
            function animate(t) {
                const p = Math.min((t - start) / dur, 1), e = 1 - Math.pow(1 - p, 3);
                cells.forEach(c => { if (c.el) { const dx = (c.tx - c.sx) * (cellSize + gap) * e, dy = (c.ty - c.sy) * (cellSize + gap) * e; c.el.style.transform = `translate(${dx}px, ${dy}px) rotate(${c.domino?.rotation || 0}deg)`; } });
                if (p < 1) requestAnimationFrame(animate); else finishRotation(indices, clockwise, cb);
            }
            requestAnimationFrame(animate);
        }

        function finishRotation(indices, clockwise, cb) {
            const saved = indices.map(i => dominos[i]), map = clockwise ? [2,0,3,1] : [1,3,0,2];
            for (let i = 0; i < 4; i++) dominos[indices[map[i]]] = saved[i];
            render(); isLocalRotating = false; setTimeout(checkFusions, 50); if (cb) cb();
        }

        function attemptRotation(x, y, dx, dy) {
            const dir = detectDiag(dx, dy); if (!dir) return false;
            const group = getGroup(x, y, dir); if (!group || !group.some(i => dominos[i])) return false;
            continuousState = { x, y, dir };
            (function step() {
                if (!continuousState) return;
                const g = getGroup(continuousState.x, continuousState.y, continuousState.dir);
                if (!g || !g.some(i => dominos[i])) { stopContinuous(); return; }
                executeRotation(g, isClockwise(continuousState.dir), () => { 
                    // V√©rifier √† nouveau que continuousState existe avant de planifier le prochain step
                    if (continuousState && !continuousTimer) {
                        continuousTimer = setTimeout(step, ROTATION_SPEED * 0.3);
                    }
                });
            })();
            return true;
        }

        function handleStart(e) {
            if (isAnimating) return; 
            if (continuousState) { stopContinuous(); return; }
            const touch = e.touches?.[0] || e, target = e.target.closest('.square'); if (!target) return;
            const idx = parseInt(target.dataset.index), pos = getPos(idx);
            dragState = { idx, x: pos.x, y: pos.y, sx: touch.clientX, sy: touch.clientY, moved: false, isEmpty: !dominos[idx] };
            e.preventDefault();
        }

        function handleMove(e) {
            if (!dragState || dragState.moved) return;
            const touch = e.touches?.[0] || e, dx = touch.clientX - dragState.sx, dy = touch.clientY - dragState.sy;
            if (detectDiag(dx, dy)) { dragState.moved = true; attemptRotation(dragState.x, dragState.y, dx, dy); }
            e.preventDefault();
        }

        function handleEnd(e) { 
            // Stopper imm√©diatement la rotation continue
            if (continuousState) {
                stopContinuous();
                // Sur mobile, emp√™cher tout √©v√©nement r√©siduel
                e?.preventDefault?.();
            }
            if (dragState && !dragState.moved && !dragState.isEmpty) queueRotation(dragState.idx);
            dragState = null; 
        }

        function queueRotation(idx) {
            rotationQueue.push(idx);
            if (rotationQueue.length === 1) processRotationQueue();
        }

        function processRotationQueue() {
            if (rotationQueue.length === 0 || isAnimating || isLocalRotating) return;
            const idx = rotationQueue[0];
            const d = dominos[idx];
            if (!d) { rotationQueue.shift(); processRotationQueue(); return; }
            saveState(); d.rotation += 90;
            const el = grid.children[idx].querySelector('.square');
            if (el) {
                el.style.transition = 'transform 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
                el.style.transform = `rotate(${d.rotation}deg)`;
                setTimeout(() => {
                    rotationQueue.shift();
                    if (rotationQueue.length > 0) processRotationQueue();
                    else checkFusions();
                }, 150);
            } else { rotationQueue.shift(); processRotationQueue(); }
        }

        function addScore(basePoints, fusionType, states) {
            const now = Date.now();
            let stateMultiplier = 1;
            states.forEach(s => { stateMultiplier = Math.max(stateMultiplier, STATE_MULTIPLIER[s] || 1); });
            if (now - lastFusionTime < 2000 && lastFusionTime > 0) comboCount++;
            else comboCount = 1;
            lastFusionTime = now;
            const comboMultiplier = 1 + (comboCount - 1) * 0.5;
            const points = Math.round(basePoints * stateMultiplier * comboMultiplier);
            score += points;
            if (score > bestScore) bestScore = score;
            updateScoreDisplay(points);
            return points;
        }

        function updateScoreDisplay(pointsAdded) {
            const scoreEl = document.getElementById('score');
            const comboEl = document.getElementById('combo');
            const bestEl = document.getElementById('best');
            scoreEl.textContent = score.toLocaleString();
            scoreEl.classList.remove('highlight'); void scoreEl.offsetWidth; scoreEl.classList.add('highlight');
            comboEl.textContent = comboCount > 1 ? `√ó${(1 + (comboCount - 1) * 0.5).toFixed(1)}` : '√ó1';
            comboEl.style.opacity = comboCount > 1 ? '1' : '0.5';
            bestEl.textContent = bestScore.toLocaleString();
        }

        function showFloatingPoints(points, x, y) {
            const el = document.createElement('div');
            el.className = 'floating-points';
            el.textContent = `+${points.toLocaleString()}`;
            el.style.left = `${x}px`; el.style.top = `${y}px`;
            // Appliquer le style blanc si l'animation est activ√©e
            if (showPointsAnimation) {
                el.style.color = 'rgba(255, 255, 255, 0.9)';
                el.style.textShadow = '0 0 8px rgba(255, 255, 255, 0.6)';
            }
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
        
        function showVictory() {
            // Overlay de victoire
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(10px);
                display: flex; flex-direction: column; align-items: center; justify-content: center;
                z-index: 10000; animation: fadeIn 0.5s ease-out;
            `;
            
            const title = document.createElement('div');
            title.textContent = 'üèÜ VICTOIRE ! üèÜ';
            title.style.cssText = `
                font-size: 3rem; font-weight: 700; color: #ffd700;
                text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4);
                margin-bottom: 20px; animation: pulse 1s ease-in-out infinite;
            `;
            
            const scoreText = document.createElement('div');
            scoreText.textContent = `Score final : ${score.toLocaleString()}`;
            scoreText.style.cssText = `
                font-size: 1.5rem; color: rgba(255, 255, 255, 0.9);
                margin-bottom: 30px;
            `;
            
            const btn = document.createElement('button');
            btn.textContent = 'Rejouer';
            btn.style.cssText = `
                padding: 15px 40px; font-size: 1.2rem; font-weight: 600;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border: none; border-radius: 12px; color: white;
                cursor: pointer; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
                transition: transform 0.2s;
            `;
            btn.onmouseover = () => btn.style.transform = 'scale(1.05)';
            btn.onmouseout = () => btn.style.transform = 'scale(1)';
            btn.onclick = () => {
                overlay.remove();
                resetGame();
            };
            
            overlay.appendChild(title);
            overlay.appendChild(scoreText);
            overlay.appendChild(btn);
            document.body.appendChild(overlay);
            
            // Animations CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
            `;
            document.head.appendChild(style);
        }

        function checkFusions(skipGravity = false) {
            if (isAnimating || isLocalRotating) return;
            // Twin fusion (priorit√© haute) - seulement si activ√©es
            if (enableTwinFusion) {
                for (let i = 0; i < TOTAL; i++) {
                    if (!dominos[i]) continue;
                    const { x, y } = getPos(i);
                    const iR = getIndex(x+1, y);
                    if (iR !== -1 && areTwins(dominos[i], dominos[iR])) { performTwinFusion(i, iR, 'h'); return; }
                    const iB = getIndex(x, y+1);
                    if (iB !== -1 && areTwins(dominos[i], dominos[iB])) { performTwinFusion(i, iB, 'v'); return; }
                }
            }
            // Chain fusion
            for (let i = 0; i < TOTAL; i++) {
                if (!dominos[i]) continue;
                const { x, y } = getPos(i);
                if (x > 0 && x < COLS-1) {
                    const iL = getIndex(x-1,y), iR = getIndex(x+1,y);
                    if (iL !== -1 && iR !== -1 && dominos[iL] && dominos[iR]) {
                        const fLR = getExposedFace(dominos[iL], 'right'), fCL = getExposedFace(dominos[i], 'left');
                        const fCR = getExposedFace(dominos[i], 'right'), fRL = getExposedFace(dominos[iR], 'left');
                        // V√©rifier aussi que les √©tats des faces expos√©es sont identiques
                        const sLR = getExposedState(dominos[iL], 'right'), sCL = getExposedState(dominos[i], 'left');
                        const sCR = getExposedState(dominos[i], 'right'), sRL = getExposedState(dominos[iR], 'left');
                        if (fLR && fCL && fLR === fCL && sLR === sCL && fCR && fRL && fCR === fRL && sCR === sRL) { 
                            performChainFusion(iL, i, iR, 'h'); return; 
                        }
                    }
                }
                if (y > 0 && y < ROWS-1) {
                    const iT = getIndex(x,y-1), iB = getIndex(x,y+1);
                    if (iT !== -1 && iB !== -1 && dominos[iT] && dominos[iB]) {
                        const fTB = getExposedFace(dominos[iT], 'bottom'), fCT = getExposedFace(dominos[i], 'top');
                        const fCB = getExposedFace(dominos[i], 'bottom'), fBT = getExposedFace(dominos[iB], 'top');
                        // V√©rifier aussi que les √©tats des faces expos√©es sont identiques
                        const sTB = getExposedState(dominos[iT], 'bottom'), sCT = getExposedState(dominos[i], 'top');
                        const sCB = getExposedState(dominos[i], 'bottom'), sBT = getExposedState(dominos[iB], 'top');
                        if (fTB && fCT && fTB === fCT && sTB === sCT && fCB && fBT && fCB === fBT && sCB === sBT) { 
                            performChainFusion(iT, i, iB, 'v'); return; 
                        }
                    }
                }
            }
            // Simple fusion
            for (let i = 0; i < TOTAL; i++) {
                if (!dominos[i]) continue;
                const { x, y } = getPos(i);
                const checks = [{ ni: getIndex(x+1,y), d1: 'right', d2: 'left', dir: 'h' }, { ni: getIndex(x,y+1), d1: 'bottom', d2: 'top', dir: 'v' }];
                for (const { ni, d1, d2, dir } of checks) {
                    if (ni === -1 || !dominos[ni]) continue;
                    const f1 = getExposedFace(dominos[i], d1), f2 = getExposedFace(dominos[ni], d2);
                    // V√©rifier aussi que les √©tats des faces expos√©es sont identiques
                    const s1 = getExposedState(dominos[i], d1), s2 = getExposedState(dominos[ni], d2);
                    if (f1 && f2 && f1 === f2 && s1 === s2) { 
                        performFusion(i, ni, dir); return; 
                    }
                }
            }
            // ‚úÖ Si on arrive ici, AUCUNE fusion n'a √©t√© d√©tect√©e
            if (Date.now() - lastFusionTime > 2000) {
                comboCount = 0;
                document.getElementById('combo').style.opacity = '0.5';
            }
            if (!skipGravity) {
                applyGravity();
            }
        }

        function performFusion(i1, i2, dir) {
            isAnimating = true;
            const d1 = dominos[i1], d2 = dominos[i2];
            const el1 = grid.children[i1].querySelector('.square'), el2 = grid.children[i2].querySelector('.square');
            if (!el1 || !el2) { isAnimating = false; return; }
            
            // Faces qui fusionnent (disparaissent)
            const fusionFace1 = getExposedFace(d1, dir === 'h' ? 'right' : 'bottom');
            const fusionFace2 = getExposedFace(d2, dir === 'h' ? 'left' : 'top');
            
            // Faces partenaires (celles qui restent)
            const nf1 = getRemainingFace(d1, dir === 'h' ? 'right' : 'bottom');
            const nf2 = getRemainingFace(d2, dir === 'h' ? 'left' : 'top');
            
            // √âtat actuel des faces qui fusionnent (utiliser getExposedState)
            const currentState = getExposedState(d1, dir === 'h' ? 'right' : 'bottom');
            const currentStateIdx = STATE_ORDER.indexOf(currentState);
            
            // Fusion simple : +1 √©tat pour les partenaires
            const nextStateIdx = Math.min(currentStateIdx + 1, STATE_ORDER.length - 1);
            const partnerState = STATE_ORDER[nextStateIdx];
            
            // Le domino jumeau (les 2 faces qui ont fusionn√©) reviendra en blanc
            const twinDomino = {
                face1: fusionFace1,
                face2: fusionFace2,
                rotation: 0
            };
            
            // Comptage des fusions par √©tat atteint
            if (partnerState !== 'white' && fusionCounts[partnerState] !== undefined) {
                fusionCounts[partnerState]++;
                document.getElementById(partnerState + '-count').textContent = fusionCounts[partnerState];
            }
            
            // Points bas√©s sur l'√©tat actuel
            let basePoints = POINTS.simple;
            if (currentState !== 'white') {
                const stateBonus = {
                    'silver': 1000,
                    'gold': 3000,
                    'emerald': 5000,
                    'cosmic': 10000,
                    'supernovae': 25000
                };
                basePoints = stateBonus[currentState] || POINTS.simple;
            }
            
            const points = addScore(basePoints, 'simple', [d1.state, d2.state]);
            const rect = el1.getBoundingClientRect();
            showFloatingPoints(points, rect.left + rect.width/2, rect.top);
            el1.classList.add('fusing'); el2.classList.add('fusing');
            const ax = dir === 'h' ? 'X' : 'Y';
            el1.style.transform = `rotate(${d1.rotation}deg) translate${ax}(25px) scale${ax}(0.7)`;
            el2.style.transform = `rotate(${d2.rotation}deg) translate${ax}(-25px) scale${ax}(0.7)`;
            setTimeout(() => {
                el1.style.opacity = el2.style.opacity = '0';
                setTimeout(() => {
                    // Le domino r√©sultant avec les faces partenaires qui prennent l'√©tat
                    dominos[i1] = { 
                        face1: nf1 || ICON_KEYS[0], 
                        face2: nf2 || ICON_KEYS[0], 
                        rotation: dir === 'h' ? 90 : 0, 
                        state: 'white',
                        state1: partnerState,
                        state2: partnerState
                    };
                    dominos[i2] = null; 
                    render();
                    setTimeout(() => { 
                        isAnimating = false;
                        // Gravit√© puis respawn du domino jumeau
                        applyGravityThenRespawn([twinDomino]);
                    }, FUSION_APPEAR);
                }, FUSION_FADE);
            }, FUSION_MOVE);
        }

        function performChainFusion(i1, i2, i3, dir) {
            isAnimating = true;
            const d1 = dominos[i1], d2 = dominos[i2], d3 = dominos[i3];
            const el1 = grid.children[i1].querySelector('.square'), el2 = grid.children[i2].querySelector('.square'), el3 = grid.children[i3].querySelector('.square');
            if (!el1 || !el2 || !el3) { isAnimating = false; return; }
            
            // Faces qui fusionnent (4 faces au total, 2 paires)
            const fusionFace1 = getExposedFace(d1, dir === 'h' ? 'right' : 'bottom'); // = face gauche du centre
            const fusionFace2 = getExposedFace(d3, dir === 'h' ? 'left' : 'top');    // = face droite du centre
            
            // Faces partenaires (les faces externes qui restent)
            const nf1 = getRemainingFace(d1, dir === 'h' ? 'left' : 'top');
            const nf2 = getRemainingFace(d3, dir === 'h' ? 'right' : 'bottom');
            
            // √âtat actuel (utiliser getExposedState)
            const currentState = getExposedState(d1, dir === 'h' ? 'right' : 'bottom');
            const currentStateIdx = STATE_ORDER.indexOf(currentState);
            
            // Fusion chain : +2 √©tats pour les partenaires
            const nextStateIdx = Math.min(currentStateIdx + 2, STATE_ORDER.length - 1);
            const partnerState = STATE_ORDER[nextStateIdx];
            
            // 2 dominos jumeaux (les 2 paires de faces qui ont fusionn√©) reviendront en blanc
            const twinDominos = [
                { face1: fusionFace1, face2: fusionFace1, rotation: 0 }, // paire 1
                { face1: fusionFace2, face2: fusionFace2, rotation: 0 }  // paire 2
            ];
            
            // Comptage des fusions
            if (partnerState !== 'white' && fusionCounts[partnerState] !== undefined) {
                fusionCounts[partnerState]++;
                document.getElementById(partnerState + '-count').textContent = fusionCounts[partnerState];
            }
            
            // Points bas√©s sur l'√©tat actuel
            let basePoints = POINTS.chain;
            if (currentState !== 'white') {
                const stateBonus = {
                    'silver': 2000,
                    'gold': 5000,
                    'emerald': 10000,
                    'cosmic': 20000,
                    'supernovae': 50000
                };
                basePoints = stateBonus[currentState] || POINTS.chain;
            }
            
            const points = addScore(basePoints, 'chain', [d1.state, d2.state, d3.state]);
            const rect = el2.getBoundingClientRect();
            showFloatingPoints(points, rect.left + rect.width/2, rect.top);
            el1.classList.add('fusing'); el2.classList.add('fusing'); el3.classList.add('fusing');
            if (dir === 'h') {
                el1.style.transform = `rotate(${d1.rotation}deg) translateX(40px) scale(0.6)`;
                el2.style.transform = `rotate(${d2.rotation}deg) scale(0.6)`;
                el3.style.transform = `rotate(${d3.rotation}deg) translateX(-40px) scale(0.6)`;
            } else {
                el1.style.transform = `rotate(${d1.rotation}deg) translateY(40px) scale(0.6)`;
                el2.style.transform = `rotate(${d2.rotation}deg) scale(0.6)`;
                el3.style.transform = `rotate(${d3.rotation}deg) translateY(-40px) scale(0.6)`;
            }
            setTimeout(() => {
                el1.style.opacity = el2.style.opacity = el3.style.opacity = '0';
                setTimeout(() => {
                    // Le domino r√©sultant avec les faces partenaires qui prennent l'√©tat
                    dominos[i2] = { 
                        face1: nf1 || ICON_KEYS[0], 
                        face2: nf2 || ICON_KEYS[0], 
                        rotation: d2.rotation, 
                        state: 'white',
                        state1: partnerState,
                        state2: partnerState
                    };
                    dominos[i1] = null; dominos[i3] = null; 
                    render();
                    setTimeout(() => { 
                        isAnimating = false;
                        // Gravit√© puis respawn des 2 dominos jumeaux
                        applyGravityThenRespawn(twinDominos);
                    }, FUSION_APPEAR);
                }, FUSION_FADE);
            }, FUSION_MOVE);
        }

        function performTwinFusion(i1, i2, dir) {
            isAnimating = true;
            const d1 = dominos[i1], d2 = dominos[i2];
            
            // √âtat actuel (utiliser state1 si disponible)
            const currentState = d1.state1 || d1.state;
            const currentStateIdx = STATE_ORDER.indexOf(currentState);
            
            // Fusion twin : +3 √©tats pour les faces du survivant
            const nextStateIdx = Math.min(currentStateIdx + 3, STATE_ORDER.length - 1);
            const partnerState = STATE_ORDER[nextStateIdx];
            
            // Le domino jumeau qui dispara√Æt (d2) reviendra en blanc
            const twinDomino = {
                face1: d2.face1,
                face2: d2.face2,
                rotation: d2.rotation
            };
            
            const el1 = grid.children[i1].querySelector('.square'), el2 = grid.children[i2].querySelector('.square');
            if (!el1 || !el2) { isAnimating = false; return; }
            
            // Comptage selon l'√©tat atteint
            if (partnerState !== 'white' && fusionCounts[partnerState] !== undefined) {
                fusionCounts[partnerState]++;
                document.getElementById(partnerState + '-count').textContent = fusionCounts[partnerState];
            }
            
            // Points bas√©s sur l'√©tat actuel
            let basePoints = POINTS.twin;
            if (currentState !== 'white') {
                const twinStateBonus = {
                    'silver': 5000,
                    'gold': 10000,
                    'emerald': 20000,
                    'cosmic': 50000,
                    'supernovae': 100000
                };
                basePoints = twinStateBonus[currentState] || POINTS.twin;
            }
            
            const points = addScore(basePoints, 'twin', [d1.state, d2.state]);
            const rect = el1.getBoundingClientRect();
            showFloatingPoints(points, rect.left + rect.width/2, rect.top);
            el1.classList.add('fusing'); el2.classList.add('fusing');
            if (dir === 'h') {
                el1.style.transform = `rotate(${d1.rotation + 180}deg) translateX(30px) scale(0.5)`;
                el2.style.transform = `rotate(${d2.rotation + 180}deg) translateX(-30px) scale(0.5)`;
            } else {
                el1.style.transform = `rotate(${d1.rotation + 180}deg) translateY(30px) scale(0.5)`;
                el2.style.transform = `rotate(${d2.rotation + 180}deg) translateY(-30px) scale(0.5)`;
            }
            setTimeout(() => {
                el1.style.opacity = el2.style.opacity = '0';
                setTimeout(() => {
                    // Le domino survivant garde ses faces mais elles prennent l'√©tat
                    dominos[i1] = { 
                        face1: d1.face1, 
                        face2: d1.face2, 
                        rotation: d1.rotation, 
                        state: 'white',
                        state1: partnerState,
                        state2: partnerState
                    };
                    dominos[i2] = null; 
                    render();
                    setTimeout(() => { 
                        isAnimating = false;
                        // Gravit√© puis respawn du domino jumeau
                        applyGravityThenRespawn([twinDomino]);
                    }, FUSION_APPEAR);
                }, FUSION_FADE);
            }, FUSION_MOVE);
        }

        function applyGravity(onComplete) {
            if (isAnimating) return; // Si d√©j√† en animation, ne pas d√©marrer
            isAnimating = true;
            let moved = true;
            const animateGravity = () => {
                moved = false;
                for (let y = ROWS - 2; y >= 0; y--) {
                    for (let x = 0; x < COLS; x++) {
                        const i = getIndex(x, y), iB = getIndex(x, y + 1);
                        if (dominos[i] && !dominos[iB]) { dominos[iB] = dominos[i]; dominos[i] = null; moved = true; }
                    }
                }
                render();
                if (moved) {
                    setTimeout(animateGravity, GRAVITY_DELAY);
                } else {
                    // Gravit√© termin√©e
                    setTimeout(() => { 
                        isAnimating = false;
                        if (onComplete) {
                            onComplete(); // Appeler le callback si fourni
                        } else {
                            checkFusions(true); // ‚úÖ skipGravity = true pour √©viter boucle infinie
                        }
                    }, 200);
                }
            };
            animateGravity();
        }

        // Faire r√©appara√Ætre des dominos jumeaux en haut de la grille
        function respawnTwinDominos(twinDominos) {
            if (twinDominos.length === 0) {
                checkFusions();
                return;
            }
            
            // Trouver les slots vides en haut (ligne 0)
            const emptySlots = [];
            for (let x = 0; x < COLS; x++) {
                const idx = getIndex(x, 0);
                if (!dominos[idx]) {
                    emptySlots.push(idx);
                }
            }
            
            if (emptySlots.length < twinDominos.length) {
                console.warn('Pas assez de place pour respawn!');
                checkFusions();
                return;
            }
            
            // Placer les dominos jumeaux dans les slots vides
            isAnimating = true;
            for (let i = 0; i < twinDominos.length; i++) {
                const twin = twinDominos[i];
                const slotIdx = emptySlots[i];
                dominos[slotIdx] = {
                    face1: twin.face1,
                    face2: twin.face2,
                    rotation: twin.rotation || 0,
                    state: 'white' // Le jumeau revient TOUJOURS en blanc
                };
            }
            
            render();
            
            setTimeout(() => {
                isAnimating = false;
                // Appliquer la gravit√© puis v√©rifier les fusions
                applyGravity();
            }, 200);
        }

        // Appliquer gravit√© puis faire respawn des jumeaux
        function applyGravityThenRespawn(twinDominos) {
            applyGravity(() => {
                setTimeout(() => respawnTwinDominos(twinDominos), 150);
            });
        }

        function applyGravityThenDrop(dropCount) {
            // Applique d'abord la gravit√© compl√®te, puis drop les nouveaux dominos
            applyGravity(() => {
                // La gravit√© est termin√©e, maintenant on peut dropper
                setTimeout(() => dropNewDominos(dropCount), 150);
            });
        }

        function saveState() { 
            history.push(JSON.parse(JSON.stringify(dominos))); 
            scoreHistory.push(score); 
            if (history.length > MAX_HISTORY) {
                history.shift();
                scoreHistory.shift();
            }
        }
        function undo() { 
            if (history.length === 0 || isAnimating || isLocalRotating) return; 
            dominos = history.pop(); 
            score = scoreHistory.pop(); 
            document.getElementById('score').textContent = score.toLocaleString();
            render(); 
        }

        function resetGame() {
            if (isAnimating || isLocalRotating) return;
            stopContinuous(); history = []; scoreHistory = []; rotationQueue = [];
            score = 0; comboCount = 0; lastFusionTime = 0;
            fusionCounts = { silver: 0, gold: 0, emerald: 0, cosmic: 0, supernovae: 0 };
            dominoSequenceIndex = 1; // Recommencer la s√©quence √† 1
            const rng = seededRandom(LEVEL_SEEDS[currentLevel]);
            const iconKeys = getIconKeysForLevel(currentLevel);
            dominos = Array.from({ length: TOTAL }, (_, i) => {
                const { x, y } = getPos(i);
                return { 
                    face1: iconKeys[Math.floor(rng() * iconKeys.length)], 
                    face2: iconKeys[Math.floor(rng() * iconKeys.length)], 
                    rotation: ((x + y) % 2 === 0) ? 0 : 90, 
                    state: 'white' 
                };
            });
            render();
            document.getElementById('score').textContent = '0';
            document.getElementById('combo').textContent = '√ó1';
            document.getElementById('combo').style.opacity = '0.5';
            document.getElementById('silver-count').textContent = '0';
            document.getElementById('gold-count').textContent = '0';
            document.getElementById('emerald-count').textContent = '0';
            document.getElementById('cosmic-count').textContent = '0';
            document.getElementById('supernovae-count').textContent = '0';
        }
        
        function setLevel(level) {
            if (isAnimating || isLocalRotating) return;
            currentLevel = level;
            document.querySelectorAll('.level-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.level-btn')[level - 1].classList.add('active');
            resetGame();
        }
        
        function toggleNotes() {
            const panel = document.getElementById('notes-panel');
            panel.classList.toggle('active');
        }
        
        function togglePointsAnimation() {
            showPointsAnimation = !showPointsAnimation;
            const btn = document.getElementById('points-anim-toggle');
            if (showPointsAnimation) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            // Sauvegarder l'√©tat
            try { localStorage.setItem('adam_points_anim', showPointsAnimation.toString()); } catch(e) {}
        }
        
        function toggleTwinFusion() {
            enableTwinFusion = !enableTwinFusion;
            const btn = document.getElementById('twin-toggle');
            if (enableTwinFusion) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            try { localStorage.setItem('adam_twin_fusion', enableTwinFusion.toString()); } catch(e) {}
        }

        try { bestScore = parseInt(localStorage.getItem('adam_best') || '0'); document.getElementById('best').textContent = bestScore.toLocaleString(); } catch(e) {}
        try { 
            const savedAnim = localStorage.getItem('adam_points_anim');
            if (savedAnim !== null) {
                showPointsAnimation = savedAnim === 'true';
                if (showPointsAnimation) document.getElementById('points-anim-toggle').classList.add('active');
            } else {
                document.getElementById('points-anim-toggle').classList.add('active'); // Actif par d√©faut
            }
        } catch(e) {}
        try { 
            const savedTwin = localStorage.getItem('adam_twin_fusion');
            if (savedTwin !== null) {
                enableTwinFusion = savedTwin === 'true';
                if (enableTwinFusion) document.getElementById('twin-toggle').classList.add('active');
            }
            // Sinon reste √† false (off par d√©faut)
        } catch(e) {}
        setInterval(() => { try { localStorage.setItem('adam_best', bestScore.toString()); } catch(e) {} }, 5000);

        document.getElementById('points-anim-toggle').addEventListener('click', togglePointsAnimation);
        document.getElementById('twin-toggle').addEventListener('click', toggleTwinFusion);
        grid.addEventListener('mousedown', handleStart);
        grid.addEventListener('touchstart', handleStart, { passive: false });
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        
        // Toggle du layer menu au clic sur le logo ADAM
        document.querySelector('.logo').addEventListener('click', () => {
            document.getElementById('settings-layer').classList.toggle('active');
        });
        
        resetGame();
    </script>
</body>
</html>
