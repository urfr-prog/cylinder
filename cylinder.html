<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Fusion Square v19</title>
    
    <!-- PWA iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Fusion">
    
    <!-- Ic√¥ne iOS (emoji cube en SVG encod√©) -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%231a1a2e'/><rect x='15' y='15' width='30' height='30' rx='6' fill='%23667eea'/><rect x='55' y='15' width='30' height='30' rx='6' fill='%2343e97b'/><rect x='15' y='55' width='30' height='30' rx='6' fill='%23fa709a'/><rect x='55' y='55' width='30' height='30' rx='6' fill='%234facfe'/></svg>">
    
    <!-- Couleur th√®me -->
    <meta name="theme-color" content="#0a0a0f">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #0a0a0f;
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height pour iOS */
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        .container {
            width: 100%;
            max-width: 390px;
            height: 100vh;
            height: 100dvh;
            max-height: 844px;
            background: linear-gradient(180deg, #0d0d15 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        /* Zone centrale avec cylindre et zones lat√©rales */
        .game-area {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-bottom: 70px; /* Espace pour la swipe-zone du bas */
        }

        .scene {
            width: 300px;
            height: 450px;
            perspective: 800px;
            perspective-origin: 50% 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cylinder {
            width: 0;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform-origin: center center;
        }

        .crown {
            position: absolute;
            width: 0;
            left: 0;
            height: 82px;
            transform-style: preserve-3d;
            transition: transform 0.25s ease-out;
        }

        .crown.dragging {
            transition: none;
        }

        .cell {
            position: absolute;
            width: 70px;
            height: 82px;
            left: -35px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.2),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                0 4px 8px rgba(0,0,0,0.3);
            backface-visibility: visible;
            cursor: pointer;
            /* Outline par d√©faut d√©sactiv√© */
            --outline-width: 0px;
            --outline-opacity: 0;
        }

        /* Classes d'outline */
        .cell.outline-1 { --outline-width: 1px; --outline-opacity: 0.9; }
        .cell.outline-2 { --outline-width: 2px; --outline-opacity: 0.9; }
        .cell.outline-3 { --outline-width: 3px; --outline-opacity: 0.9; }

        .cell.outline-1,
        .cell.outline-2,
        .cell.outline-3 {
            border: var(--outline-width) solid rgba(255, 255, 255, var(--outline-opacity));
        }

        /* Cellule d√©truite avec outline persistant (ghost) */
        /* Opacit√© par d√©faut pour l'arri√®re: 20% */
        .cell.destroyed.outline-ghost {
            opacity: 1 !important;
            background: transparent !important;
            box-shadow: none !important;
            border: var(--outline-width) solid rgba(255, 255, 255, 0.20);
        }
        
        /* Opacit√© renforc√©e pour les 4 colonnes de fa√ßade: 35% */
        .cell.destroyed.outline-ghost.ghost-front {
            border: var(--outline-width) solid rgba(255, 255, 255, 0.35);
        }

        /* √âtat pendant le long press */
        .cell.pressing {
            animation: pressGlow 0.4s ease-out forwards;
        }

        @keyframes pressGlow {
            0% { 
                box-shadow: 
                    inset 0 2px 4px rgba(255,255,255,0.2), 
                    inset 0 -2px 4px rgba(0,0,0,0.2), 
                    0 4px 8px rgba(0,0,0,0.3),
                    0 0 0 0 rgba(255,255,255,0);
            }
            100% { 
                box-shadow: 
                    inset 0 2px 4px rgba(255,255,255,0.2), 
                    inset 0 -2px 4px rgba(0,0,0,0.2), 
                    0 4px 8px rgba(0,0,0,0.3),
                    0 0 25px 8px rgba(255,255,255,0.6);
            }
        }

        /* Animation de swap */
        .cell.swap-out {
            animation: swapOut 0.4s ease-in-out forwards;
        }

        .cell.swap-in {
            animation: swapIn 0.4s ease-in-out forwards;
        }

        @keyframes swapOut {
            0% { transform: rotateY(var(--base-angle)) translateZ(140px) scale(1); opacity: 1; }
            50% { transform: rotateY(var(--base-angle)) translateZ(70px) scale(0.3); opacity: 0.3; }
            100% { transform: rotateY(var(--base-angle)) translateZ(140px) scale(1); opacity: 1; }
        }

        @keyframes swapIn {
            0% { transform: rotateY(var(--base-angle)) translateZ(140px) scale(1); opacity: 0.2; }
            50% { transform: rotateY(var(--base-angle)) translateZ(210px) scale(0.3); opacity: 0.4; }
            100% { transform: rotateY(var(--base-angle)) translateZ(140px) scale(1); opacity: 1; }
        }

        /* 5 couleurs */
        .color-0 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .color-1 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .color-2 { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .color-3 { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .color-4 { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #333; }

        .cell.destroying {
            animation: destroy 0.5s ease-out forwards;
        }
        
        @keyframes destroy {
            0% { transform: rotateY(var(--base-angle)) translateZ(140px) scale(1); opacity: 1; }
            50% { transform: rotateY(var(--base-angle)) translateZ(140px) scale(1.2); opacity: 0.8; }
            100% { transform: rotateY(var(--base-angle)) translateZ(140px) scale(0); opacity: 0; }
        }
        
        /* Destroyed sans ghost = invisible */
        .cell.destroyed:not(.outline-ghost) {
            opacity: 0 !important;
            pointer-events: none;
        }

        /* =====================================================
           ZONES DE CONTR√îLE GRAVIT√â (lat√©rales)
           ===================================================== */
        .gravity-zone {
            position: absolute;
            width: 50px;
            top: 0;
            bottom: 80px; /* Laisse de l'espace pour la swipe-zone du bas */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            cursor: pointer;
        }

        .gravity-zone.left {
            left: 0;
        }

        .gravity-zone.right {
            right: 0;
        }

        .gravity-zone .hint-vertical {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            color: rgba(255, 255, 255, 0.35);
            font-size: 12px;
            letter-spacing: 3px;
            pointer-events: none;
        }

        /* Animation de feedback gravit√© */
        .gravity-zone.activated-down {
            animation: gravityPulseDown 0.3s ease-out;
        }
        
        .gravity-zone.activated-up {
            animation: gravityPulseUp 0.3s ease-out;
        }

        @keyframes gravityPulseDown {
            0% { background: rgba(255, 150, 100, 0); }
            50% { background: rgba(255, 150, 100, 0.3); }
            100% { background: rgba(255, 150, 100, 0); }
        }
        
        @keyframes gravityPulseUp {
            0% { background: rgba(100, 200, 255, 0); }
            50% { background: rgba(100, 200, 255, 0.3); }
            100% { background: rgba(100, 200, 255, 0); }
        }

        .swipe-zone {
            position: absolute;
            bottom: 0;
            left: 50px; /* Laisse de l'espace pour les zones lat√©rales */
            right: 50px;
            height: 150px; /* Tr√®s haute - arrive presque au cylindre */
            display: flex;
            justify-content: center;
            align-items: flex-end; /* Texte en bas */
            padding-bottom: 20px;
            cursor: grab;
            background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, transparent 100%);
        }

        .swipe-zone:active {
            cursor: grabbing;
        }

        .hint {
            color: rgba(255,255,255,0.4);
            font-size: 14px;
            letter-spacing: 2px;
        }

        /* =====================================================
           DEBUG PANEL - CONSOLE AVANC√âE COMPACTE
           ===================================================== */
        .debug-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.95);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 12px;
            border-radius: 10px;
            z-index: 1000;
            width: 520px;
            max-height: 95vh;
            overflow-y: auto;
            display: none;
            border: 1px solid #0f0;
        }

        .debug-panel.visible {
            display: block;
        }

        .debug-panel h4 {
            margin: 0 0 10px 0;
            color: #0f0;
            font-size: 14px;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }

        .debug-row {
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-row-compact {
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
        }

        .debug-label {
            color: #888;
        }

        .debug-value {
            color: #0f0;
            font-weight: bold;
        }

        .debug-value.highlight {
            color: #ff0;
        }

        .debug-value.error {
            color: #f55;
        }

        .debug-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,255,0,0.3);
            color: #fff;
            border: 1px solid #0f0;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            z-index: 1001;
        }

        .debug-toggle:hover {
            background: rgba(0,255,0,0.5);
        }

        .debug-section {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }

        .debug-section-title {
            color: #ff0;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 6px;
        }

        /* Layout 2 colonnes pour infos compactes */
        .debug-two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .debug-column {
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            padding: 8px;
        }

        .debug-column-title {
            color: #ff0;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 4px;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }

        /* Grille debug - compacte */
        .debug-grid {
            font-size: 10px;
            line-height: 1.2;
        }

        .debug-grid-header {
            display: flex;
            gap: 2px;
            margin-bottom: 3px;
            padding-left: 26px;
        }

        .debug-grid-header span {
            width: 24px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-weight: bold;
            font-size: 9px;
        }

        .debug-grid-header span.front {
            color: #0f0;
            background: rgba(0,255,0,0.15);
            border-radius: 3px;
        }

        .debug-grid-header span.back {
            color: #f80;
            background: rgba(255,136,0,0.15);
            border-radius: 3px;
        }

        .debug-grid-header span.active {
            outline: 2px solid #ff0;
        }

        .debug-grid-row {
            display: flex;
            gap: 2px;
            align-items: center;
            margin-bottom: 1px;
        }

        .debug-grid-row-label {
            width: 24px;
            color: #888;
            font-size: 9px;
            text-align: right;
            padding-right: 2px;
        }

        .debug-grid-cell {
            width: 24px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-weight: bold;
            font-size: 9px;
            flex-direction: column;
            line-height: 1;
        }

        /* Couleurs debug synchronis√©es avec les d√©grad√©s du cylindre */
        .debug-grid-cell.c0 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; }
        .debug-grid-cell.c1 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: #fff; }
        .debug-grid-cell.c2 { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: #fff; }
        .debug-grid-cell.c3 { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: #fff; }
        .debug-grid-cell.c4 { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #333; }
        .debug-grid-cell.dead { background: #333; color: #666; }

        .debug-grid-cell .face-num {
            font-size: 7px;
            opacity: 0.7;
        }

        .debug-grid-cell.target {
            outline: 2px solid #ff0;
            outline-offset: 1px;
        }

        /* Options debug - inline compact */
        .debug-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 6px;
        }

        .debug-option {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .debug-option input[type="checkbox"] {
            width: 12px;
            height: 12px;
            cursor: pointer;
        }

        .debug-option label {
            color: #aaa;
            font-size: 10px;
            cursor: pointer;
        }

        /* Outline thickness selector - compact */
        .outline-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            padding: 6px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
        }

        .outline-controls label {
            color: #aaa;
            font-size: 10px;
        }

        .thickness-buttons {
            display: flex;
            gap: 3px;
        }

        .thickness-btn {
            width: 24px;
            height: 20px;
            background: #222;
            border: 1px solid #555;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
        }

        .thickness-btn:hover {
            background: #333;
            border-color: #0f0;
        }

        .thickness-btn.active {
            background: #0f0;
            color: #000;
            border-color: #0f0;
        }

        /* Horizontal line option - style invers√© */
        .horizontal-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 8px;
            padding: 4px 8px;
            background: rgba(255,100,100,0.1);
            border-radius: 4px;
            border: 1px solid rgba(255,100,100,0.3);
        }

        .horizontal-controls.disabled {
            opacity: 0.4;
            border-color: #333;
        }

        .horizontal-controls label {
            color: #f88;
            font-size: 10px;
        }

        .debug-action {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .debug-action button {
            background: #222;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }

        .debug-action button:hover {
            background: #333;
            border-color: #0f0;
        }

        /* L√©gende compacte */
        .debug-legend {
            display: flex;
            gap: 10px;
            margin-top: 4px;
            font-size: 9px;
        }

        .debug-legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .debug-legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .debug-legend-color.front { background: rgba(0,255,0,0.4); border: 1px solid #0f0; }
        .debug-legend-color.back { background: rgba(255,136,0,0.4); border: 1px solid #f80; }
        .debug-legend-color.target { background: #333; border: 2px solid #ff0; }

        /* Selects compacts */
        .debug-select-compact {
            width: 100%;
            padding: 4px;
            background: #222;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <button class="debug-toggle" onclick="toggleDebug()">üîß DEBUG</button>
    
    <div class="debug-panel" id="debugPanel">
        <h4>üéÆ Fusion Square v19 - Gravit√© Manuelle</h4>
        
        <!-- ===================== SECTION HAUTE: Options importantes ===================== -->
        
        <!-- Options d'affichage + Outline + Horizontal 5 carr√©s -->
        <div class="debug-section">
            <div class="debug-section-title">‚öôÔ∏è OPTIONS D'AFFICHAGE</div>
            <div class="debug-options">
                <div class="debug-option">
                    <input type="checkbox" id="optShowFaceNum" checked onchange="updateDebugGrid()">
                    <label for="optShowFaceNum">N¬∞ Face</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="optShowColor" checked onchange="updateDebugGrid()">
                    <label for="optShowColor">Couleur</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="optShowOnCells" onchange="toggleCellDisplay()">
                    <label for="optShowOnCells">Sur cylindre</label>
                </div>
            </div>
            
            <!-- Ligne Outline + Option 5 horizontaux -->
            <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 4px; margin-top: 6px;">
                <div class="outline-controls">
                    <input type="checkbox" id="optOutline" checked onchange="toggleOutline()">
                    <label for="optOutline" style="color:#fff;font-weight:bold;">üî≤ Outline</label>
                    <div class="thickness-buttons">
                        <button class="thickness-btn active" data-thickness="1" onclick="setOutlineThickness(1)">1</button>
                        <button class="thickness-btn" data-thickness="2" onclick="setOutlineThickness(2)">2</button>
                        <button class="thickness-btn" data-thickness="3" onclick="setOutlineThickness(3)">3</button>
                    </div>
                    <span style="color:#666;font-size:9px;">px</span>
                </div>
                
                <div class="horizontal-controls" id="horizontalControls">
                    <input type="checkbox" id="optHorizontal5" onchange="toggleHorizontal5()">
                    <label for="optHorizontal5">‚ÜîÔ∏è 5 Horiz.</label>
                </div>
            </div>
        </div>

        <!-- Palettes et Niveaux -->
        <div class="debug-section">
            <div class="debug-section-title">üé® PALETTES & NIVEAUX</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <div>
                    <label class="debug-label" style="font-size:9px;">Palette:</label>
                    <select id="paletteSelect" onchange="applyPalette(this.value)" class="debug-select-compact">
                        <option value="neon">üåà Neon Nights</option>
                        <option value="sunset">üåÖ Sunset Fire</option>
                        <option value="cyberpunk">ü§ñ Cyberpunk</option>
                        <option value="candy">üç¨ Candy Pop</option>
                    </select>
                </div>
                <div>
                    <label class="debug-label" style="font-size:9px;">Niveau:</label>
                    <select id="mappingSelect" onchange="loadMapping(this.value)" class="debug-select-compact">
                        <option value="mapping1">üü¢ D√©butant - Colonnes</option>
                        <option value="mapping2">üü¢ D√©butant - Quasi-lignes</option>
                        <option value="mapping3">üü° Facile - Damier</option>
                        <option value="mapping4">üü° Facile - Vagues</option>
                        <option value="mapping5">üü† Moyen - Spirale</option>
                        <option value="mapping6" selected>üü† Moyen - Miroir bris√©</option>
                        <option value="mapping7">üî¥ Difficile - Chaos</option>
                        <option value="mapping8">üî¥ Difficile - Entropie</option>
                        <option value="mapping9">üíÄ Expert - Dispersion</option>
                        <option value="mapping10">‚ò†Ô∏è Cauchemar</option>
                    </select>
                </div>
            </div>
            <div class="debug-row" style="margin-top:4px;">
                <span class="debug-label">Mapping:</span>
                <span class="debug-value" id="dbgCurrentMapping" style="font-size: 10px;">Moyen - Miroir bris√©</span>
            </div>
        </div>

        <!-- Grille Visuelle -->
        <div class="debug-section">
            <div class="debug-section-title">üìä GRILLE VISUELLE (col -2 √† +7)</div>
            <div class="debug-legend">
                <div class="debug-legend-item">
                    <div class="debug-legend-color front"></div>
                    <span style="color:#0f0">Front</span>
                </div>
                <div class="debug-legend-item">
                    <div class="debug-legend-color back"></div>
                    <span style="color:#f80">Back</span>
                </div>
                <div class="debug-legend-item">
                    <div class="debug-legend-color target"></div>
                    <span style="color:#ff0">Cible</span>
                </div>
            </div>
            <div class="debug-grid-header" id="dbgGridHeader"></div>
            <div class="debug-grid" id="dbgGrid"></div>
        </div>

        <!-- ===================== SECTION BASSE: 2 colonnes ===================== -->
        <div class="debug-section">
            <div class="debug-two-columns">
                <!-- Colonne gauche: Rotations + Touch -->
                <div class="debug-column">
                    <div class="debug-column-title">üìê ROTATIONS</div>
                    <div class="debug-row-compact">
                        <span class="debug-label">globalRotation:</span>
                        <span class="debug-value" id="dbgGlobal">18¬∞</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">crownRotations:</span>
                        <span class="debug-value" id="dbgCrownRot" style="font-size:9px;">[0,0,0,0,0]</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">centerFace:</span>
                        <span class="debug-value" id="dbgCenterFaces" style="font-size:9px;">[0,0,0,0,0]</span>
                    </div>
                    
                    <div class="debug-column-title" style="margin-top:6px;">üëÜ TOUCH</div>
                    <div class="debug-row-compact">
                        <span class="debug-label">offsetX:</span>
                        <span class="debug-value" id="dbgTouchX">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">visualCol:</span>
                        <span class="debug-value highlight" id="dbgVisualCol">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">touchRow:</span>
                        <span class="debug-value" id="dbgTouchRow">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">front:</span>
                        <span class="debug-value highlight" id="dbgTargetFront">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">back:</span>
                        <span class="debug-value" id="dbgTargetBack">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">gesture:</span>
                        <span class="debug-value" id="dbgGesture">idle</span>
                    </div>
                </div>

                <!-- Colonne droite: √âtat jeu + Difficult√© -->
                <div class="debug-column">
                    <div class="debug-column-title">üéØ √âTAT JEU</div>
                    <div class="debug-row-compact">
                        <span class="debug-label">cellules:</span>
                        <span class="debug-value" id="dbgAlive">50/50</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">Swapping:</span>
                        <span class="debug-value" id="dbgSwapping">false</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">Destroying:</span>
                        <span class="debug-value" id="dbgDestroying">false</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">üî≤ Outline:</span>
                        <span class="debug-value" id="dbgOutline">OFF</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">‚ÜîÔ∏è Horiz5:</span>
                        <span class="debug-value" id="dbgHorizontal5">OFF</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">üîÑ Flipping:</span>
                        <span class="debug-value" id="dbgFlipping">false</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">‚¨áÔ∏è Last Gravity:</span>
                        <span class="debug-value" id="dbgLastGravity">-</span>
                    </div>
                    
                    <div class="debug-column-title" style="margin-top:6px;">üìä DIFFICULT√â</div>
                    <div class="debug-row-compact">
                        <span class="debug-label">Quasi-lignes:</span>
                        <span class="debug-value" id="dbgQuasiLines">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">Adjacences:</span>
                        <span class="debug-value" id="dbgAdjacent">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">Paires:</span>
                        <span class="debug-value" id="dbgUsefulPairs">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">Dispersion:</span>
                        <span class="debug-value" id="dbgDispersion">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label" style="color:#ff0;">SCORE:</span>
                        <span class="debug-value highlight" id="dbgDifficultyScore" style="font-size:12px;">-</span>
                    </div>
                    <div class="debug-row-compact">
                        <span class="debug-label">Niveau:</span>
                        <span class="debug-value" id="dbgDifficultyLevel" style="font-size:11px;">-</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="debug-action">
            <button onclick="resetGame()">üîÑ Reset</button>
            <button onclick="logFullState()">üìã Log</button>
            <button onclick="analyzeDifficulty()">üìä Analyser</button>
            <button onclick="testSwapAt(0, 0)">Test F0/R0</button>
        </div>
    </div>

    <div class="container">
        <div class="game-area">
            <!-- Zone gravit√© gauche -->
            <div class="gravity-zone left" id="gravityZoneLeft">
                <span class="hint-vertical">‚Üë SWIPE ‚Üì</span>
            </div>

            <!-- Sc√®ne centrale -->
            <div class="scene" id="scene">
                <div class="cylinder" id="cylinder"></div>
            </div>

            <!-- Zone gravit√© droite -->
            <div class="gravity-zone right" id="gravityZoneRight">
                <span class="hint-vertical">‚Üë SWIPE ‚Üì</span>
            </div>
        </div>

        <!-- Zone swipe rotation globale -->
        <div class="swipe-zone" id="swipeZone">
            <div class="hint"><span>‚Üê SWIPE ‚Üí</span></div>
        </div>
    </div>

    <script>
        // =====================================================
        // CONSTANTES
        // =====================================================
        const FACES = 10;
        const ROWS = 5;
        const COLORS = 5;
        const RADIUS = 140;
        const ANGLE_STEP = 360 / FACES; // 36¬∞
        const CELL_WIDTH = 70;

        // Position initiale : 18¬∞ = vue de c√¥t√© (5 faces visibles)
        const INITIAL_ROTATION = 18;

        // =====================================================
        // PARAM√àTRES LONG PRESS
        // =====================================================
        const LONG_PRESS = {
            duration: 400,
            moveThreshold: 20
        };

        // =====================================================
        // PARAM√àTRES D'INTERACTION
        // =====================================================
        const INTERACTION = {
            rotationSensitivity: 0.35,
            maxDeltaDegrees: 12,
            maxDeltaPixels: 80,
            directionThreshold: 18,
            verticalSwipeThreshold: 50,  // Pixels pour d√©clencher un flip
            horizontalMaxForVertical: 30, // Max horizontal autoris√© pendant un swipe vertical
            gravitySwipeThreshold: 40     // Seuil pour d√©clencher gravit√© manuelle
        };

        // =====================================================
        // PALETTES DE COULEURS
        // =====================================================
        const COLOR_PALETTES = {
            neon: {
                name: 'üåà Neon Nights',
                colors: [
                    'linear-gradient(135deg, #ff006e 0%, #ff4da6 100%)',  // Rose n√©on
                    'linear-gradient(135deg, #00f5ff 0%, #00b4d8 100%)',  // Cyan √©lectrique
                    'linear-gradient(135deg, #39ff14 0%, #7fff00 100%)',  // Vert fluo
                    'linear-gradient(135deg, #bf00ff 0%, #8000ff 100%)',  // Violet laser
                    'linear-gradient(135deg, #ffff00 0%, #ffd000 100%)'   // Jaune flash
                ],
                textColors: ['#fff', '#000', '#000', '#fff', '#000']
            },
            sunset: {
                name: 'üåÖ Sunset Fire',
                colors: [
                    'linear-gradient(135deg, #ff4500 0%, #ff6a00 100%)',  // Orange br√ªlant
                    'linear-gradient(135deg, #ff0055 0%, #ff3377 100%)',  // Rouge magenta
                    'linear-gradient(135deg, #ff9500 0%, #ffb700 100%)',  // Or soleil
                    'linear-gradient(135deg, #9d00ff 0%, #c77dff 100%)',  // Violet cr√©puscule
                    'linear-gradient(135deg, #00d4ff 0%, #0099cc 100%)'   // Bleu horizon
                ],
                textColors: ['#fff', '#fff', '#000', '#fff', '#000']
            },
            cyberpunk: {
                name: 'ü§ñ Cyberpunk',
                colors: [
                    'linear-gradient(135deg, #f72585 0%, #b5179e 100%)',  // Magenta cyber
                    'linear-gradient(135deg, #4cc9f0 0%, #4361ee 100%)',  // Bleu n√©on
                    'linear-gradient(135deg, #06ffa5 0%, #00cc7a 100%)',  // Vert matrix
                    'linear-gradient(135deg, #fee440 0%, #ffaa00 100%)',  // Jaune warning
                    'linear-gradient(135deg, #9b5de5 0%, #7b2cbf 100%)'   // Violet glitch
                ],
                textColors: ['#fff', '#fff', '#000', '#000', '#fff']
            },
            candy: {
                name: 'üç¨ Candy Pop',
                colors: [
                    'linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%)',  // Rose bonbon
                    'linear-gradient(135deg, #00e5ff 0%, #69f0ae 100%)',  // Menthe glac√©e
                    'linear-gradient(135deg, #ffd93d 0%, #ffe066 100%)',  // Citron acidul√©
                    'linear-gradient(135deg, #c9b1ff 0%, #a18aff 100%)',  // Lavande douce
                    'linear-gradient(135deg, #ff8a5c 0%, #ffa07a 100%)'   // P√™che sucr√©e
                ],
                textColors: ['#000', '#000', '#000', '#000', '#000']
            }
        };

        // =====================================================
        // MAPPINGS DE GRILLES (10 niveaux)
        // =====================================================
        const GRID_MAPPINGS = {
            mapping1: {
                name: 'üü¢ D√©butant - Colonnes proches',
                difficulty: 'Tr√®s Facile',
                grid: [
                    [0, 0, 1, 1, 2],
                    [1, 1, 2, 2, 3],
                    [2, 2, 3, 3, 4],
                    [3, 3, 4, 4, 0],
                    [4, 4, 0, 0, 1],
                    [0, 1, 1, 2, 2],
                    [1, 2, 2, 3, 3],
                    [2, 3, 3, 4, 4],
                    [3, 4, 4, 0, 0],
                    [4, 0, 0, 1, 1]
                ]
            },
            mapping2: {
                name: 'üü¢ D√©butant - Quasi-lignes',
                difficulty: 'Tr√®s Facile',
                grid: [
                    [0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 2],
                    [2, 2, 2, 2, 3],
                    [3, 3, 3, 3, 4],
                    [4, 4, 4, 4, 0],
                    [0, 0, 0, 1, 0],
                    [1, 1, 1, 2, 1],
                    [2, 2, 2, 3, 2],
                    [3, 3, 3, 4, 3],
                    [4, 4, 4, 0, 4]
                ]
            },
            mapping3: {
                name: 'üü° Facile - Damier',
                difficulty: 'Facile',
                grid: [
                    [0, 1, 0, 1, 0],
                    [1, 2, 1, 2, 1],
                    [2, 3, 2, 3, 2],
                    [3, 4, 3, 4, 3],
                    [4, 0, 4, 0, 4],
                    [0, 1, 0, 1, 0],
                    [1, 2, 1, 2, 1],
                    [2, 3, 2, 3, 2],
                    [3, 4, 3, 4, 3],
                    [4, 0, 4, 0, 4]
                ]
            },
            mapping4: {
                name: 'üü° Facile - Vagues',
                difficulty: 'Facile',
                grid: [
                    [0, 1, 2, 1, 0],
                    [1, 2, 3, 2, 1],
                    [2, 3, 4, 3, 2],
                    [3, 4, 0, 4, 3],
                    [4, 0, 1, 0, 4],
                    [0, 1, 2, 1, 0],
                    [1, 2, 3, 2, 1],
                    [2, 3, 4, 3, 2],
                    [3, 4, 0, 4, 3],
                    [4, 0, 1, 0, 4]
                ]
            },
            mapping5: {
                name: 'üü† Moyen - Spirale',
                difficulty: 'Moyen',
                grid: [
                    [0, 1, 2, 3, 4],
                    [4, 0, 1, 2, 3],
                    [3, 4, 0, 1, 2],
                    [2, 3, 4, 0, 1],
                    [1, 2, 3, 4, 0],
                    [0, 1, 2, 3, 4],
                    [4, 0, 1, 2, 3],
                    [3, 4, 0, 1, 2],
                    [2, 3, 4, 0, 1],
                    [1, 2, 3, 4, 0]
                ]
            },
            mapping6: {
                name: 'üü† Moyen - Miroir bris√©',
                difficulty: 'Moyen',
                grid: [
                    [2, 0, 3, 1, 4],
                    [1, 3, 0, 4, 2],
                    [4, 2, 1, 0, 3],
                    [0, 4, 2, 3, 1],
                    [3, 1, 4, 2, 0],
                    [2, 3, 0, 1, 4],
                    [4, 0, 3, 2, 1],
                    [1, 4, 2, 0, 3],
                    [3, 2, 1, 4, 0],
                    [0, 1, 4, 3, 2]
                ]
            },
            mapping7: {
                name: 'üî¥ Difficile - Chaos ordonn√©',
                difficulty: 'Difficile',
                grid: [
                    [3, 1, 4, 0, 2],
                    [0, 4, 2, 3, 1],
                    [2, 0, 3, 1, 4],
                    [4, 3, 1, 2, 0],
                    [1, 2, 0, 4, 3],
                    [2, 4, 1, 3, 0],
                    [1, 0, 4, 2, 3],
                    [4, 3, 0, 1, 2],
                    [0, 2, 3, 4, 1],
                    [3, 1, 2, 0, 4]
                ]
            },
            mapping8: {
                name: 'üî¥ Difficile - Entropie',
                difficulty: 'Difficile',
                grid: [
                    [1, 4, 2, 0, 3],
                    [3, 0, 4, 2, 1],
                    [0, 2, 1, 3, 4],
                    [4, 1, 3, 0, 2],
                    [2, 3, 0, 4, 1],
                    [1, 0, 4, 3, 2],
                    [4, 2, 3, 1, 0],
                    [3, 4, 0, 2, 1],
                    [0, 3, 2, 1, 4],
                    [2, 1, 1, 4, 3]
                ]
            },
            mapping9: {
                name: 'üíÄ Expert - Dispersion max',
                difficulty: 'Tr√®s Dur',
                grid: [
                    [0, 2, 4, 1, 3],
                    [3, 1, 0, 4, 2],
                    [1, 4, 3, 2, 0],
                    [4, 0, 2, 3, 1],
                    [2, 3, 1, 0, 4],
                    [3, 1, 4, 2, 0],
                    [0, 4, 2, 1, 3],
                    [4, 2, 0, 3, 1],
                    [1, 3, 4, 0, 2],
                    [2, 0, 3, 4, 1]
                ]
            },
            mapping10: {
                name: '‚ò†Ô∏è Cauchemar - Aucune piti√©',
                difficulty: 'Extr√™me',
                grid: [
                    [4, 1, 3, 0, 2],
                    [2, 0, 4, 3, 1],
                    [0, 3, 2, 1, 4],
                    [1, 4, 0, 2, 3],
                    [3, 2, 1, 4, 0],
                    [1, 0, 4, 3, 2],
                    [3, 4, 1, 2, 0],
                    [2, 1, 3, 0, 4],
                    [4, 2, 0, 1, 3],
                    [0, 3, 2, 4, 1]
                ]
            }
        };

        let currentPalette = 'neon';
        let currentMapping = 'mapping6'; // Celui d'origine (Moyen)

        // =====================================================
        // √âTAT DU JEU
        // =====================================================
        let globalRotation = INITIAL_ROTATION;
        let crownRotations = [0, 0, 0, 0, 0];
        let gridByFace = [];
        let cellState = [];
        let isDestroying = false;
        let isSwapping = false;

        // √âtat Touch/Swap
        let longPressTimeout = null;
        let longPressStartX = 0;
        let longPressStartY = 0;
        let longPressFrozenFace = null;  // Face fig√©e au moment du touch
        let longPressFrozenRow = null;
        let longPressFrozenVisualCol = null;
        let isLongPressing = false;
        let currentGesture = 'idle';

        // Debug
        let dbgTouchXOffset = 0;
        let showCellInfo = false;
        
        // Gravit√© manuelle (plus de gravit√© automatique)
        let isApplyingGravity = false;
        let lastGravityAction = '-'; // Pour debug

        // Outline
        let outlineEnabled = true;
        let outlineThickness = 1; // D√©faut: 1px

        // Column Flip
        let isFlipping = false;

        // 5 Carr√©s Horizontaux cons√©cutifs (s'annule si activ√© avec vertical)
        let horizontal5Enabled = false;

        function initGrid() {
            gridByFace = [];
            cellState = [];
            const mapping = GRID_MAPPINGS[currentMapping].grid;
            for (let f = 0; f < FACES; f++) {
                gridByFace[f] = [...mapping[f]];
                cellState[f] = [true, true, true, true, true];
            }
            isDestroying = false;
            isSwapping = false;
        }

        // =====================================================
        // FONCTIONS DE CONVERSION - CRITIQUES
        // =====================================================
        
        /**
         * Retourne la face data au centre pour une row donn√©e
         * √Ä 18¬∞ de rotation, la face centrale est entre F9 et F0
         * On consid√®re que visualCol -1 = F9 et visualCol 0 = F0
         */
        function getCenterDataFaceForRow(row) {
            const totalRotation = globalRotation + crownRotations[row];
            // Normaliser entre 0 et 360
            const normalized = ((totalRotation % 360) + 360) % 360;
            // Convertir en index de face
            // √Ä 0¬∞ ‚Üí face 0 est devant
            // √Ä 36¬∞ ‚Üí face 9 est devant (rotation horaire)
            // √Ä 18¬∞ ‚Üí entre face 9 et 0
            const rawFace = -normalized / ANGLE_STEP;
            const face = Math.round(rawFace);
            return ((face % FACES) + FACES) % FACES;
        }
        
        /**
         * Convertit une colonne visuelle en face data pour une row donn√©e
         * visualCol: -2, -1, 0, 1 (les 4 colonnes de fa√ßade)
         * 
         * √Ä globalRotation = 18¬∞ et crownRotation = 0:
         *   visualCol -2 ‚Üí F8
         *   visualCol -1 ‚Üí F9
         *   visualCol  0 ‚Üí F0
         *   visualCol  1 ‚Üí F1
         */
        function getDataFaceForVisualColumnAndRow(visualCol, row) {
            // La face "de r√©f√©rence" pour cette row
            // √Ä 18¬∞, c'est F0 (car round(-18/36) = round(-0.5) = 0)
            const refFace = getCenterDataFaceForRow(row);
            
            // Ajuster: √† 18¬∞, visualCol 0 correspond √† refFace (F0)
            // visualCol -1 ‚Üí F9 (refFace - 1)
            // visualCol -2 ‚Üí F8 (refFace - 2)
            // visualCol +1 ‚Üí F1 (refFace + 1)
            const dataFace = ((refFace + visualCol) % FACES + FACES) % FACES;
            
            return dataFace;
        }

        /**
         * Retourne la face oppos√©e (back) d'une face donn√©e
         */
        function getBackFace(face) {
            return (face + 5) % FACES;
        }

        // =====================================================
        // D√âTECTION POSITION TOUCH - MESURES R√âELLES
        // =====================================================
        
        // Bas√© sur les mesures r√©elles √† globalRotation = 18¬∞
        // Seules les 4 colonnes de FA√áADE r√©pondent au touch
        // Les faces arri√®re visibles dans les interstices sont IGNOR√âES
        
        // Structure: visualCol ‚Üí plage de pixels
        // visualCol -2 = face la plus √† gauche visible (F8 dans la vue initiale)
        // visualCol -1 = face gauche centrale (F9)
        // visualCol  0 = face droite centrale (F0) - ATTENTION: d√©cal√© car vue √† 18¬∞
        // visualCol +1 = face la plus √† droite visible (F1)
        
        const FRONT_HIT_ZONES = [
            { col: -2, min: -155, max: -105 },  // F8 - bord gauche
            { col: -1, min: -95, max: -15 },    // F9 - centre gauche
            // GAP: -15 √† +10 = interstice central ‚Üí AUCUNE D√âTECTION
            { col: 0,  min: 10, max: 95 },      // F0 - centre droit  
            { col: 1,  min: 105, max: 155 }     // F1 - bord droit
        ];
        
        function getVisualColumnFromX(x) {
            const scene = document.getElementById('scene');
            const rect = scene.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const offsetX = x - centerX;
            
            dbgTouchXOffset = offsetX;
            
            // Chercher dans les zones de fa√ßade uniquement
            for (const zone of FRONT_HIT_ZONES) {
                if (offsetX >= zone.min && offsetX <= zone.max) {
                    return zone.col;
                }
            }
            
            // Hors zone fa√ßade = interstice ou arri√®re ‚Üí pas de d√©tection
            return null;
        }
        
        function getRowFromY(y) {
            const scene = document.getElementById('scene');
            const rect = scene.getBoundingClientRect();
            const relativeY = y - rect.top;
            
            const sceneHeight = 450;
            const zoneHeight = sceneHeight / ROWS; // 90px
            
            if (relativeY < 0) return 0;
            if (relativeY >= sceneHeight) return ROWS - 1;
            
            return Math.min(Math.floor(relativeY / zoneHeight), ROWS - 1);
        }

        // =====================================================
        // PROTECTION ANTI-EMBALLEMENT RENFORC√âE
        // =====================================================
        let lastMoveTime = 0;
        let velocityBuffer = [];
        const MAX_VELOCITY_SAMPLES = 5;
        
        function sanitizeDelta(deltaPixels) {
            const now = performance.now();
            
            // Si trop de temps entre deux moves, reset (nouveau geste)
            if (now - lastMoveTime > 100) {
                velocityBuffer = [];
            }
            lastMoveTime = now;
            
            // Ignorer les deltas trop grands (bug ou multitouch)
            if (Math.abs(deltaPixels) > INTERACTION.maxDeltaPixels) {
                return 0;
            }
            
            // Ignorer les micro-mouvements (bruit)
            if (Math.abs(deltaPixels) < 1) {
                return 0;
            }
            
            // Calculer la v√©locit√© et d√©tecter l'emballement
            velocityBuffer.push(Math.abs(deltaPixels));
            if (velocityBuffer.length > MAX_VELOCITY_SAMPLES) {
                velocityBuffer.shift();
            }
            
            // Si la moyenne des derniers mouvements est trop √©lev√©e, freiner
            if (velocityBuffer.length >= 3) {
                const avgVelocity = velocityBuffer.reduce((a, b) => a + b, 0) / velocityBuffer.length;
                if (avgVelocity > 30) {
                    // Emballement d√©tect√© - appliquer une friction forte
                    deltaPixels *= 0.3;
                }
            }
            
            // Convertir en degr√©s avec sensibilit√©
            let deltaDegrees = deltaPixels * INTERACTION.rotationSensitivity;
            
            // Clamp final
            deltaDegrees = Math.max(-INTERACTION.maxDeltaDegrees, Math.min(INTERACTION.maxDeltaDegrees, deltaDegrees));
            
            return deltaDegrees;
        }
        
        // Reset velocity buffer quand on rel√¢che
        function resetVelocity() {
            velocityBuffer = [];
            lastMoveTime = 0;
        }

        // =====================================================
        // LONG PRESS & SWAP
        // =====================================================
        
        function startLongPress(x, y) {
            if (isSwapping || isDestroying) return;
            
            const row = getRowFromY(y);
            const visualCol = getVisualColumnFromX(x);
            
            // Toujours initialiser pour permettre le drag
            longPressStartX = x;
            longPressStartY = y;
            isLongPressing = true;
            
            // Si on n'est pas sur une cellule valide, permettre le drag mais pas le swap
            if (visualCol === null) {
                console.log(`[TOUCH] Interstice d√©tect√© - drag possible, swap impossible (offset: ${dbgTouchXOffset.toFixed(0)}px)`);
                currentGesture = 'pending_drag_only';  // Nouvel √©tat: peut drag mais pas swap
                longPressFrozenVisualCol = null;
                longPressFrozenRow = row;
                longPressFrozenFace = null;
                updateDebug();
                return;
            }
            
            const dataFace = getDataFaceForVisualColumnAndRow(visualCol, row);
            
            // FIGER les valeurs au moment du touch
            longPressFrozenVisualCol = visualCol;
            longPressFrozenRow = row;
            longPressFrozenFace = dataFace;
            currentGesture = 'pending';
            
            console.log(`[TOUCH] Col ${visualCol}, Row ${row} ‚Üí Face ${dataFace} (offset: ${dbgTouchXOffset.toFixed(0)}px)`);
            
            // Feedback visuel imm√©diat
            const cell = document.querySelector(`.cell[data-face="${dataFace}"][data-row="${row}"]`);
            if (cell && cellState[dataFace][row]) {
                const angle = dataFace * ANGLE_STEP;
                cell.style.setProperty('--base-angle', angle + 'deg');
                cell.classList.add('pressing');
            }
            
            longPressTimeout = setTimeout(() => {
                if (isLongPressing && currentGesture === 'pending') {
                    currentGesture = 'longpress';
                    // Utiliser les valeurs FIG√âES
                    triggerSwap(longPressFrozenFace, longPressFrozenRow);
                }
            }, LONG_PRESS.duration);
            
            updateDebug();
        }
        
        function cancelLongPress() {
            if (longPressTimeout) {
                clearTimeout(longPressTimeout);
                longPressTimeout = null;
            }
            
            document.querySelectorAll('.cell.pressing').forEach(cell => {
                cell.classList.remove('pressing');
            });
            
            isLongPressing = false;
            
            // Ne reset l'√©tat que si on n'est PAS en train de drag
            if (currentGesture !== 'drag') {
                longPressFrozenFace = null;
                longPressFrozenRow = null;
                longPressFrozenVisualCol = null;
                // Ne pas mettre idle ici - laisser le touchend/mouseup le faire
            }
            
            updateDebug();
        }
        
        function checkLongPressMove(x, y) {
            // Ne v√©rifier que si on est en attente d'un swap potentiel
            if (!isLongPressing) return false;
            if (currentGesture !== 'pending' && currentGesture !== 'pending_drag_only') return false;
            
            const dx = x - longPressStartX;
            const dy = y - longPressStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > LONG_PRESS.moveThreshold) {
                // Ne pas appeler cancelLongPress ici, juste annuler le timeout
                if (longPressTimeout) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;
                }
                document.querySelectorAll('.cell.pressing').forEach(cell => {
                    cell.classList.remove('pressing');
                });
                isLongPressing = false;
                return true;
            }
            return false;
        }
        
        function triggerSwap(frontFace, row) {
            if (isSwapping || frontFace === null || row === null) return;
            
            const backFace = getBackFace(frontFace);
            
            const frontAlive = cellState[frontFace][row];
            const backAlive = cellState[backFace][row];
            
            console.log(`[SWAP] Front F${frontFace}/R${row} (alive:${frontAlive}) ‚Üî Back F${backFace}/R${row} (alive:${backAlive})`);
            
            if (!frontAlive && !backAlive) {
                cancelLongPress();
                return;
            }
            
            isSwapping = true;
            updateDebug();
            
            const frontCell = document.querySelector(`.cell[data-face="${frontFace}"][data-row="${row}"]`);
            const backCell = document.querySelector(`.cell[data-face="${backFace}"][data-row="${row}"]`);
            
            if (!frontCell || !backCell) {
                isSwapping = false;
                cancelLongPress();
                return;
            }
            
            frontCell.classList.remove('pressing');
            
            const frontAngle = frontFace * ANGLE_STEP;
            const backAngle = backFace * ANGLE_STEP;
            
            frontCell.style.setProperty('--base-angle', frontAngle + 'deg');
            backCell.style.setProperty('--base-angle', backAngle + 'deg');
            
            if (frontAlive) frontCell.classList.add('swap-out');
            if (backAlive) backCell.classList.add('swap-in');
            
            // Swap des donn√©es √† mi-animation
            setTimeout(() => {
                const tempColor = gridByFace[frontFace][row];
                gridByFace[frontFace][row] = gridByFace[backFace][row];
                gridByFace[backFace][row] = tempColor;
                
                const tempState = cellState[frontFace][row];
                cellState[frontFace][row] = cellState[backFace][row];
                cellState[backFace][row] = tempState;
                
                updateCellAppearance(frontCell, frontFace, row);
                updateCellAppearance(backCell, backFace, row);
            }, 200);
            
            // Fin animation
            setTimeout(() => {
                frontCell.classList.remove('swap-out');
                backCell.classList.remove('swap-in');
                
                frontCell.style.transform = `rotateY(${frontAngle}deg) translateZ(${RADIUS}px)`;
                backCell.style.transform = `rotateY(${backAngle}deg) translateZ(${RADIUS}px)`;
                
                if (!cellState[frontFace][row]) {
                    frontCell.classList.add('destroyed');
                    if (outlineEnabled) {
                        frontCell.classList.add('outline-ghost');
                    }
                    frontCell.style.opacity = '0';
                }
                if (!cellState[backFace][row]) {
                    backCell.classList.add('destroyed');
                    if (outlineEnabled) {
                        backCell.classList.add('outline-ghost');
                    }
                    backCell.style.opacity = '0';
                }
                
                isSwapping = false;
                cancelLongPress();
                
                // V√©rifier les lignes (pas de gravit√© automatique)
                checkVerticalLines();
            }, 400);
        }
        
        function updateCellAppearance(cell, face, row) {
            const color = gridByFace[face][row];
            const alive = cellState[face][row];
            
            cell.className = cell.className.replace(/color-\d/g, '').trim();
            cell.classList.add(`color-${color}`);
            cell.classList.add('cell');
            
            // Appliquer l'outline si activ√©
            applyOutlineToCell(cell);
            
            if (alive) {
                cell.classList.remove('destroyed');
                cell.classList.remove('outline-ghost');
                cell.style.opacity = '1';
            } else {
                cell.classList.add('destroyed');
                if (outlineEnabled) {
                    cell.classList.add('outline-ghost');
                }
                cell.style.opacity = '0';
            }
            
            // Mettre √† jour le contenu si option activ√©e
            if (showCellInfo) {
                cell.innerHTML = `<div style="font-size:14px;font-weight:bold;">F${face}</div><div style="font-size:10px;opacity:0.7;">c${color}</div>`;
            }
        }

        // =====================================================
        // V√âRIFICATION LIGNES VERTICALES ET HORIZONTALES
        // =====================================================
        function checkVerticalLines() {
            if (isDestroying) return;
            
            // Collecter TOUTES les colonnes verticales valides
            const allColumnsToDestroy = [];
            
            for (let f = 0; f < FACES; f++) {
                const columnData = getValidColumn(f);
                if (columnData) {
                    allColumnsToDestroy.push(columnData);
                }
            }
            
            // Collecter les lignes horizontales si l'option est activ√©e
            if (horizontal5Enabled) {
                const horizontalLines = checkHorizontalLines();
                if (horizontalLines.length > 0) {
                    allColumnsToDestroy.push(...horizontalLines);
                }
            }
            
            // Si des colonnes/lignes √† d√©truire, les traiter toutes
            if (allColumnsToDestroy.length > 0) {
                destroyMultipleColumns(allColumnsToDestroy);
            }
        }
        
        /**
         * V√©rifie les lignes horizontales (5 cons√©cutifs m√™me couleur sur une row)
         * Retourne un tableau de lignes √† d√©truire
         */
        function checkHorizontalLines() {
            const linesToDestroy = [];
            
            // Pour chaque row
            for (let r = 0; r < ROWS; r++) {
                // Obtenir l'offset de rotation de cette couronne
                const rowRotationOffset = Math.round(crownRotations[r] / ANGLE_STEP);
                
                // V√©rifier chaque point de d√©part possible sur le cylindre (10 faces)
                for (let startVisualFace = 0; startVisualFace < FACES; startVisualFace++) {
                    let consecutiveCount = 0;
                    let firstColor = null;
                    const consecutiveFaces = [];
                    
                    // Parcourir 5 faces cons√©cutives
                    for (let i = 0; i < 5; i++) {
                        const visualFace = (startVisualFace + i) % FACES;
                        const dataFace = ((visualFace - rowRotationOffset) % FACES + FACES) % FACES;
                        
                        if (!cellState[dataFace][r]) {
                            break;
                        }
                        
                        const color = gridByFace[dataFace][r];
                        
                        if (i === 0) {
                            firstColor = color;
                            consecutiveCount = 1;
                            consecutiveFaces.push(dataFace);
                        } else if (color === firstColor) {
                            consecutiveCount++;
                            consecutiveFaces.push(dataFace);
                        } else {
                            break;
                        }
                    }
                    
                    // Si on a trouv√© 5 cons√©cutifs de m√™me couleur
                    if (consecutiveCount === 5) {
                        // Cr√©er l'objet ligne (structure compatible avec colonnes)
                        // faces: tableau des faces pour chaque "row" - ici c'est horizontal donc on met la row fixe
                        const facesArray = consecutiveFaces.map(f => f);
                        
                        // Pour √™tre compatible avec destroyMultipleColumns, on adapte le format
                        // On cr√©e un objet sp√©cial pour les lignes horizontales
                        linesToDestroy.push({
                            type: 'horizontal',
                            row: r,
                            dataFaces: consecutiveFaces,
                            color: firstColor
                        });
                        
                        console.log(`[HORIZONTAL] Ligne trouv√©e Row ${r}: faces ${consecutiveFaces.join(',')} couleur ${firstColor}`);
                    }
                }
            }
            
            return linesToDestroy;
        }
        
        /**
         * V√©rifie si une colonne visuelle est valide (5 cellules de m√™me couleur)
         * Retourne les faces concern√©es ou null
         */
        function getValidColumn(face) {
            let allSameColor = true;
            let allAlive = true;
            let firstColor = null;
            const actualFaces = [];
            
            for (let r = 0; r < ROWS; r++) {
                const rowRotationOffset = Math.round(crownRotations[r] / ANGLE_STEP);
                const actualFace = ((face - rowRotationOffset) % FACES + FACES) % FACES;
                actualFaces.push(actualFace);
                
                if (!cellState[actualFace][r]) {
                    allAlive = false;
                    break;
                }
                
                const color = gridByFace[actualFace][r];
                if (firstColor === null) {
                    firstColor = color;
                } else if (color !== firstColor) {
                    allSameColor = false;
                    break;
                }
            }
            
            if (allAlive && allSameColor && firstColor !== null) {
                return { type: 'vertical', faces: actualFaces, color: firstColor };
            }
            return null;
        }
        
        /**
         * D√©truit plusieurs colonnes/lignes simultan√©ment
         */
        function destroyMultipleColumns(columns) {
            isDestroying = true;
            updateDebug();
            
            // Marquer toutes les cellules comme mortes
            const allCellsToDestroy = [];
            columns.forEach(col => {
                if (col.type === 'horizontal') {
                    // Ligne horizontale: toutes les faces sont sur la m√™me row
                    col.dataFaces.forEach(df => {
                        const key = `${df}-${col.row}`;
                        if (!allCellsToDestroy.find(c => c.key === key)) {
                            allCellsToDestroy.push({ face: df, row: col.row, key });
                        }
                    });
                } else {
                    // Colonne verticale: une face par row
                    for (let r = 0; r < ROWS; r++) {
                        const df = col.faces[r];
                        const key = `${df}-${r}`;
                        if (!allCellsToDestroy.find(c => c.key === key)) {
                            allCellsToDestroy.push({ face: df, row: r, key });
                        }
                    }
                }
            });
            
            // Animer et d√©truire
            allCellsToDestroy.forEach((cellData, index) => {
                const { face: df, row: r } = cellData;
                cellState[df][r] = false;
                
                const cell = document.querySelector(`.cell[data-face="${df}"][data-row="${r}"]`);
                if (cell) {
                    const angle = df * ANGLE_STEP;
                    cell.style.setProperty('--base-angle', angle + 'deg');
                    
                    setTimeout(() => {
                        cell.classList.add('destroying');
                        setTimeout(() => {
                            cell.classList.remove('destroying');
                            cell.classList.add('destroyed');
                            if (outlineEnabled) {
                                cell.classList.add('outline-ghost');
                            }
                            cell.style.opacity = '0';
                        }, 500);
                    }, (index % ROWS) * 100); // √âtaler l'animation
                }
            });
            
            console.log(`[DESTROY] ${columns.length} colonne(s) d√©truite(s), ${allCellsToDestroy.length} cellules`);
            
            // Calculer le d√©lai total bas√© sur le nombre de cellules
            const totalDelay = Math.min(allCellsToDestroy.length, ROWS) * 100 + 600;
            
            setTimeout(() => {
                isDestroying = false;
                updateDebug();
                updateGhostFrontClasses();
                // PAS de gravit√© automatique - le joueur contr√¥le
            }, totalDelay);
        }

        // =====================================================
        // CONSTRUCTION CYLINDRE
        // =====================================================
        function buildCylinder() {
            const cylinder = document.getElementById('cylinder');
            cylinder.innerHTML = '';

            const crownTops = [0, 90, 180, 270, 360];

            for (let r = 0; r < ROWS; r++) {
                const crown = document.createElement('div');
                crown.className = 'crown';
                crown.dataset.row = r;
                crown.style.top = crownTops[r] + 'px';

                for (let f = 0; f < FACES; f++) {
                    const cell = document.createElement('div');
                    const color = gridByFace[f][r];
                    cell.className = `cell color-${color}`;
                    cell.dataset.face = f;
                    cell.dataset.row = r;
                    
                    // Appliquer l'outline si activ√©
                    applyOutlineToCell(cell);
                    
                    if (!cellState[f][r]) {
                        cell.classList.add('destroyed');
                        if (outlineEnabled) {
                            cell.classList.add('outline-ghost');
                        }
                        cell.style.opacity = '0';
                    }
                    
                    const angle = f * ANGLE_STEP;
                    cell.style.transform = `rotateY(${angle}deg) translateZ(${RADIUS}px)`;
                    cell.style.setProperty('--base-angle', angle + 'deg');
                    
                    // Contenu selon option - S√âPAR√â PROPREMENT
                    if (showCellInfo) {
                        cell.innerHTML = `<div style="font-size:14px;font-weight:bold;">F${f}</div><div style="font-size:10px;opacity:0.7;">c${color}</div>`;
                    }
                    
                    crown.appendChild(cell);
                }

                cylinder.appendChild(crown);
            }
            updateAllRotations();
            // Mettre √† jour les ghost-front apr√®s construction
            updateGhostFrontClasses();
        }

        // =====================================================
        // OUTLINE SYSTEM
        // =====================================================
        
        function applyOutlineToCell(cell) {
            // Retirer les anciennes classes d'outline
            cell.classList.remove('outline-1', 'outline-2', 'outline-3');
            
            if (outlineEnabled) {
                cell.classList.add(`outline-${outlineThickness}`);
            }
        }
        
        /**
         * Met √† jour les classes ghost-front sur toutes les cellules d√©truites
         * Les 4 colonnes de fa√ßade ont une opacit√© de 30%, le reste 20%
         */
        function updateGhostFrontClasses() {
            if (!outlineEnabled) return;
            
            // Pour chaque row, d√©terminer quelles faces sont en fa√ßade
            for (let r = 0; r < ROWS; r++) {
                // Les 4 colonnes visuelles de fa√ßade: -2, -1, 0, 1
                const frontFaces = [];
                for (let vc = -2; vc <= 1; vc++) {
                    frontFaces.push(getDataFaceForVisualColumnAndRow(vc, r));
                }
                
                // Parcourir toutes les cellules de cette row
                for (let f = 0; f < FACES; f++) {
                    const cell = document.querySelector(`.cell[data-face="${f}"][data-row="${r}"]`);
                    if (!cell) continue;
                    
                    // Si c'est un ghost (d√©truit avec outline)
                    if (cell.classList.contains('outline-ghost')) {
                        if (frontFaces.includes(f)) {
                            cell.classList.add('ghost-front');
                        } else {
                            cell.classList.remove('ghost-front');
                        }
                    }
                }
            }
        }

        // =====================================================
        // COLUMN FLIP SYSTEM (Swipe Vertical)
        // =====================================================
        
        /**
         * Effectue un flip miroir vertical sur une colonne visuelle
         * Row 0 ‚Üî Row 4, Row 1 ‚Üî Row 3, Row 2 reste fixe
         */
        function triggerColumnFlip(visualCol) {
            if (isFlipping || isSwapping || isDestroying || isApplyingGravity) return;
            
            isFlipping = true;
            console.log(`[FLIP] Colonne visuelle ${visualCol}`);
            
            // R√©cup√©rer les faces data pour chaque row de cette colonne visuelle
            const columnFaces = [];
            for (let r = 0; r < ROWS; r++) {
                const df = getDataFaceForVisualColumnAndRow(visualCol, r);
                columnFaces.push(df);
            }
            
            // Sauvegarder les donn√©es actuelles
            const savedColors = [];
            const savedStates = [];
            for (let r = 0; r < ROWS; r++) {
                const df = columnFaces[r];
                savedColors.push(gridByFace[df][r]);
                savedStates.push(cellState[df][r]);
            }
            
            // Effectuer le miroir : 0‚Üî4, 1‚Üî3, 2 reste
            // Nouvelle position = 4 - ancienne position
            for (let r = 0; r < ROWS; r++) {
                const mirrorR = ROWS - 1 - r; // 0‚Üí4, 1‚Üí3, 2‚Üí2, 3‚Üí1, 4‚Üí0
                const df = columnFaces[r];
                
                gridByFace[df][r] = savedColors[mirrorR];
                cellState[df][r] = savedStates[mirrorR];
            }
            
            // Animation visuelle
            animateColumnFlip(columnFaces, () => {
                isFlipping = false;
                updateDebug();
                
                // V√©rifier les lignes apr√®s le flip (pas de gravit√© auto)
                setTimeout(() => {
                    checkVerticalLines();
                }, 50);
            });
        }
        
        /**
         * Animation du flip de colonne
         */
        function animateColumnFlip(columnFaces, callback) {
            // Ajouter une classe d'animation aux cellules concern√©es
            const cells = [];
            for (let r = 0; r < ROWS; r++) {
                const df = columnFaces[r];
                const cell = document.querySelector(`.cell[data-face="${df}"][data-row="${r}"]`);
                if (cell) {
                    cells.push({ cell, face: df, row: r });
                    cell.style.transition = 'transform 0.3s ease-in-out, opacity 0.15s';
                    cell.style.opacity = '0.5';
                    cell.style.transform += ' scale(0.8)';
                }
            }
            
            // √Ä mi-chemin, mettre √† jour l'apparence
            setTimeout(() => {
                cells.forEach(({ cell, face, row }) => {
                    updateCellAppearance(cell, face, row);
                });
            }, 150);
            
            // Fin de l'animation
            setTimeout(() => {
                cells.forEach(({ cell, face, row }) => {
                    const angle = face * ANGLE_STEP;
                    cell.style.transition = 'transform 0.3s ease-out';
                    cell.style.opacity = cellState[face][row] ? '1' : '0';
                    cell.style.transform = `rotateY(${angle}deg) translateZ(${RADIUS}px)`;
                });
                
                // Reset des transitions apr√®s animation
                setTimeout(() => {
                    cells.forEach(({ cell }) => {
                        cell.style.transition = '';
                    });
                    updateGhostFrontClasses();
                    if (callback) callback();
                }, 300);
            }, 150);
        }
        
        function toggleOutline() {
            outlineEnabled = document.getElementById('optOutline').checked;
            console.log('[OUTLINE] ' + (outlineEnabled ? `Activ√© (${outlineThickness}px)` : 'D√©sactiv√©'));
            
            // Mettre √† jour l'affichage des boutons
            updateThicknessButtons();
            
            // Reconstruire le cylindre pour appliquer
            buildCylinder();
            updateDebug();
        }
        
        function setOutlineThickness(thickness) {
            outlineThickness = thickness;
            console.log(`[OUTLINE] √âpaisseur: ${thickness}px`);
            
            // Mettre √† jour les boutons
            updateThicknessButtons();
            
            // Activer automatiquement l'outline si on change l'√©paisseur
            if (!outlineEnabled) {
                outlineEnabled = true;
                document.getElementById('optOutline').checked = true;
            }
            
            // Reconstruire
            buildCylinder();
            updateDebug();
        }
        
        function updateThicknessButtons() {
            document.querySelectorAll('.thickness-btn').forEach(btn => {
                const t = parseInt(btn.dataset.thickness);
                if (t === outlineThickness && outlineEnabled) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function updateAllRotations() {
            const cylinder = document.getElementById('cylinder');
            const crowns = cylinder.querySelectorAll('.crown');
            
            crowns.forEach((crown, index) => {
                const totalRotation = globalRotation + crownRotations[index];
                crown.style.transform = `rotateY(${totalRotation}deg)`;
            });
            
            // Mettre √† jour les classes ghost-front selon la nouvelle rotation
            updateGhostFrontClasses();
            
            updateDebug();
        }

        function setDragging(crownIndex, isDragging) {
            const crowns = document.querySelectorAll('.crown');
            if (crownIndex < 0) {
                crowns.forEach(c => {
                    if (isDragging) c.classList.add('dragging');
                    else c.classList.remove('dragging');
                });
            } else {
                if (isDragging) crowns[crownIndex].classList.add('dragging');
                else crowns[crownIndex].classList.remove('dragging');
            }
        }

        function snapToViewPosition(rotation) {
            return Math.round(rotation / ANGLE_STEP) * ANGLE_STEP + INITIAL_ROTATION % ANGLE_STEP;
        }

        function snapGlobal() {
            globalRotation = snapToViewPosition(globalRotation);
            updateAllRotations();
        }

        function snapCrown(crownIndex) {
            crownRotations[crownIndex] = Math.round(crownRotations[crownIndex] / ANGLE_STEP) * ANGLE_STEP;
            updateAllRotations();
            
            setTimeout(() => {
                checkVerticalLines();
            }, 300);
        }

        // =====================================================
        // DEBUG - CONSOLE AVANC√âE
        // =====================================================
        function toggleDebug() {
            document.getElementById('debugPanel').classList.toggle('visible');
            updateDebug();
        }

        function toggleCellDisplay() {
            showCellInfo = document.getElementById('optShowOnCells').checked;
            buildCylinder();
        }

        function toggleHorizontal5() {
            horizontal5Enabled = document.getElementById('optHorizontal5').checked;
            console.log('[HORIZONTAL 5] ' + (horizontal5Enabled ? 'Activ√©e' : 'D√©sactiv√©e'));
            
            // Mise √† jour visuelle du contr√¥le
            const controls = document.getElementById('horizontalControls');
            if (horizontal5Enabled) {
                controls.classList.remove('disabled');
            } else {
                controls.classList.add('disabled');
            }
            
            updateDebug();
            
            // V√©rifier imm√©diatement les lignes si activ√©
            if (horizontal5Enabled) {
                setTimeout(() => {
                    checkVerticalLines();
                }, 100);
            }
        }

        // =====================================================
        // GESTION DES PALETTES ET MAPPINGS
        // =====================================================
        
        function applyPalette(paletteName) {
            currentPalette = paletteName;
            const palette = COLOR_PALETTES[paletteName];
            
            // Mettre √† jour le CSS dynamiquement
            const styleSheet = document.styleSheets[0];
            
            // Supprimer les anciennes r√®gles de couleur (cylindre ET debug)
            const rulesToDelete = [];
            for (let i = 0; i < styleSheet.cssRules.length; i++) {
                const rule = styleSheet.cssRules[i];
                if (rule.selectorText && (rule.selectorText.startsWith('.color-') || rule.selectorText.startsWith('.debug-grid-cell.c'))) {
                    rulesToDelete.push(i);
                }
            }
            // Supprimer en ordre inverse pour ne pas d√©caler les indices
            for (let i = rulesToDelete.length - 1; i >= 0; i--) {
                styleSheet.deleteRule(rulesToDelete[i]);
            }
            
            // Ajouter les nouvelles r√®gles pour le cylindre
            for (let i = 0; i < 5; i++) {
                const rule = `.color-${i} { background: ${palette.colors[i]}; color: ${palette.textColors[i]}; }`;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
            }
            
            // Ajouter les nouvelles r√®gles pour la grille debug (m√™mes couleurs)
            for (let i = 0; i < 5; i++) {
                const rule = `.debug-grid-cell.c${i} { background: ${palette.colors[i]}; color: ${palette.textColors[i]}; }`;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
            }
            
            // Mettre √† jour le s√©lecteur
            document.getElementById('paletteSelect').value = paletteName;
            
            console.log(`[PALETTE] ${palette.name}`);
            buildCylinder();
            updateDebugGrid(); // Rafra√Æchir la grille debug
        }
        
        function loadMapping(mappingName) {
            currentMapping = mappingName;
            const mapping = GRID_MAPPINGS[mappingName];
            
            // Mettre √† jour le s√©lecteur
            document.getElementById('mappingSelect').value = mappingName;
            
            console.log(`[MAPPING] ${mapping.name} (${mapping.difficulty})`);
            
            // Reset avec le nouveau mapping
            globalRotation = INITIAL_ROTATION;
            crownRotations = [0, 0, 0, 0, 0];
            lastGravityAction = '-';
            cancelLongPress();
            initGrid();
            buildCylinder();
            updateDebug();
            analyzeDifficulty();
        }

        // =====================================================
        // SYST√àME DE GRAVIT√â MANUELLE
        // =====================================================
        
        /**
         * Applique la gravit√© (vers le bas) - UNE SEULE FOIS
         */
        function applyGravityDown() {
            if (isApplyingGravity || isDestroying || isSwapping) return;
            
            isApplyingGravity = true;
            let somethingMoved = false;
            
            for (let visualFace = 0; visualFace < FACES; visualFace++) {
                const columnFaces = [];
                for (let r = 0; r < ROWS; r++) {
                    const rowRotationOffset = Math.round(crownRotations[r] / ANGLE_STEP);
                    const actualDataFace = ((visualFace - rowRotationOffset) % FACES + FACES) % FACES;
                    columnFaces.push(actualDataFace);
                }
                
                // De bas en haut : chercher les trous et faire tomber
                for (let r = ROWS - 1; r >= 0; r--) {
                    const dataFace = columnFaces[r];
                    
                    if (!cellState[dataFace][r]) {
                        // Cellule vide, chercher la premi√®re vivante au-dessus
                        for (let above = r - 1; above >= 0; above--) {
                            const aboveDataFace = columnFaces[above];
                            
                            if (cellState[aboveDataFace][above]) {
                                // Transf√©rer
                                gridByFace[dataFace][r] = gridByFace[aboveDataFace][above];
                                cellState[dataFace][r] = true;
                                cellState[aboveDataFace][above] = false;
                                somethingMoved = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            if (somethingMoved) {
                lastGravityAction = '‚Üì DOWN';
                console.log('[GRAVITY] ‚Üì Gravit√© appliqu√©e');
                buildCylinder();
                updateDebug();
                
                setTimeout(() => {
                    isApplyingGravity = false;
                    checkVerticalLines();
                }, 300);
            } else {
                lastGravityAction = '‚Üì (rien)';
                isApplyingGravity = false;
                updateDebug();
            }
        }
        
        /**
         * Applique l'anti-gravit√© (vers le haut) - UNE SEULE FOIS
         */
        function applyGravityUp() {
            if (isApplyingGravity || isDestroying || isSwapping) return;
            
            isApplyingGravity = true;
            let somethingMoved = false;
            
            for (let visualFace = 0; visualFace < FACES; visualFace++) {
                const columnFaces = [];
                for (let r = 0; r < ROWS; r++) {
                    const rowRotationOffset = Math.round(crownRotations[r] / ANGLE_STEP);
                    const actualDataFace = ((visualFace - rowRotationOffset) % FACES + FACES) % FACES;
                    columnFaces.push(actualDataFace);
                }
                
                // De haut en bas : chercher les trous et faire monter
                for (let r = 0; r < ROWS; r++) {
                    const dataFace = columnFaces[r];
                    
                    if (!cellState[dataFace][r]) {
                        // Cellule vide, chercher la premi√®re vivante en-dessous
                        for (let below = r + 1; below < ROWS; below++) {
                            const belowDataFace = columnFaces[below];
                            
                            if (cellState[belowDataFace][below]) {
                                // Transf√©rer
                                gridByFace[dataFace][r] = gridByFace[belowDataFace][below];
                                cellState[dataFace][r] = true;
                                cellState[belowDataFace][below] = false;
                                somethingMoved = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            if (somethingMoved) {
                lastGravityAction = '‚Üë UP';
                console.log('[GRAVITY] ‚Üë Anti-gravit√© appliqu√©e');
                buildCylinder();
                updateDebug();
                
                setTimeout(() => {
                    isApplyingGravity = false;
                    checkVerticalLines();
                }, 300);
            } else {
                lastGravityAction = '‚Üë (rien)';
                isApplyingGravity = false;
                updateDebug();
            }
        }

        function countAliveCells() {
            let count = 0;
            for (let f = 0; f < FACES; f++) {
                for (let r = 0; r < ROWS; r++) {
                    if (cellState[f][r]) count++;
                }
            }
            return count;
        }

        function updateDebug() {
            // Rotations
            document.getElementById('dbgGlobal').textContent = globalRotation.toFixed(1) + '¬∞';
            document.getElementById('dbgCrownRot').textContent = '[' + crownRotations.map(r => r.toFixed(0)).join(',') + ']';
            
            // Center faces per row
            const centerFaces = [];
            for (let r = 0; r < ROWS; r++) {
                centerFaces.push(getCenterDataFaceForRow(r));
            }
            document.getElementById('dbgCenterFaces').textContent = JSON.stringify(centerFaces);
            
            // Touch info
            document.getElementById('dbgTouchX').textContent = dbgTouchXOffset.toFixed(0) + 'px';
            document.getElementById('dbgVisualCol').textContent = longPressFrozenVisualCol !== null ? longPressFrozenVisualCol : (dbgTouchXOffset !== 0 ? '‚ö†Ô∏è interstice' : '-');
            document.getElementById('dbgTouchRow').textContent = longPressFrozenRow !== null ? longPressFrozenRow : '-';
            document.getElementById('dbgTargetFront').textContent = longPressFrozenFace !== null ? `F${longPressFrozenFace}` : '-';
            document.getElementById('dbgTargetBack').textContent = longPressFrozenFace !== null ? `F${getBackFace(longPressFrozenFace)}` : '-';
            document.getElementById('dbgGesture').textContent = currentGesture;
            
            // √âtat jeu
            document.getElementById('dbgAlive').textContent = countAliveCells() + '/50';
            document.getElementById('dbgSwapping').textContent = isSwapping;
            document.getElementById('dbgDestroying').textContent = isDestroying;
            
            // Outline
            const outlineStatus = outlineEnabled ? `ON (${outlineThickness}px)` : 'OFF';
            document.getElementById('dbgOutline').textContent = outlineStatus;
            document.getElementById('dbgOutline').style.color = outlineEnabled ? '#0f0' : '#f55';
            
            // Horizontal 5
            document.getElementById('dbgHorizontal5').textContent = horizontal5Enabled ? 'ON' : 'OFF';
            document.getElementById('dbgHorizontal5').style.color = horizontal5Enabled ? '#f88' : '#888';
            
            // Flip
            document.getElementById('dbgFlipping').textContent = isFlipping;
            
            // Gravit√© manuelle - derni√®re action
            document.getElementById('dbgLastGravity').textContent = lastGravityAction;
            document.getElementById('dbgLastGravity').style.color = lastGravityAction.includes('UP') ? '#4facfe' : (lastGravityAction.includes('DOWN') ? '#f80' : '#888');
            
            // Mapping actuel
            if (document.getElementById('dbgCurrentMapping')) {
                const mapping = GRID_MAPPINGS[currentMapping];
                document.getElementById('dbgCurrentMapping').textContent = mapping.name.replace(/^[^\s]+\s/, '');
            }
            
            // Grille
            updateDebugGrid();
        }

        function updateDebugGrid() {
            const showFaceNum = document.getElementById('optShowFaceNum').checked;
            const showColor = document.getElementById('optShowColor').checked;
            
            // Header (colonnes -2 √† +7)
            let headerHtml = '';
            for (let vc = -2; vc <= 7; vc++) {
                let cls = '';
                if (vc >= -2 && vc <= 2) cls = 'front';
                else if (vc >= 3 && vc <= 7) cls = 'back';
                if (longPressFrozenVisualCol !== null && vc === longPressFrozenVisualCol) cls += ' active';
                headerHtml += `<span class="${cls}">${vc}</span>`;
            }
            document.getElementById('dbgGridHeader').innerHTML = headerHtml;
            
            // Grille
            let gridHtml = '';
            for (let r = 0; r < ROWS; r++) {
                gridHtml += '<div class="debug-grid-row">';
                gridHtml += `<span class="debug-grid-row-label">Row ${r}</span>`;
                
                for (let vc = -2; vc <= 7; vc++) {
                    const df = getDataFaceForVisualColumnAndRow(vc, r);
                    const color = gridByFace[df][r];
                    const alive = cellState[df][r];
                    
                    // Est-ce la cible du swap ?
                    const isTarget = (longPressFrozenFace !== null && longPressFrozenRow === r &&
                                     (df === longPressFrozenFace || df === getBackFace(longPressFrozenFace)));
                    
                    const targetClass = isTarget ? ' target' : '';
                    
                    if (alive) {
                        let content = '';
                        if (showFaceNum) content += `<span class="face-num">F${df}</span>`;
                        if (showColor) content += color;
                        gridHtml += `<div class="debug-grid-cell c${color}${targetClass}">${content}</div>`;
                    } else {
                        gridHtml += `<div class="debug-grid-cell dead${targetClass}">X</div>`;
                    }
                }
                gridHtml += '</div>';
            }
            document.getElementById('dbgGrid').innerHTML = gridHtml;
        }

        function resetGame() {
            globalRotation = INITIAL_ROTATION;
            crownRotations = [0, 0, 0, 0, 0];
            lastGravityAction = '-';
            cancelLongPress();
            initGrid();
            buildCylinder();
            updateDebug();
            analyzeDifficulty();
            console.log('[RESET] Plateau r√©initialis√©');
        }

        function logFullState() {
            console.log('=== √âTAT COMPLET v19 ===');
            console.log('globalRotation:', globalRotation);
            console.log('crownRotations:', crownRotations);
            console.log('centerFacesPerRow:', Array.from({length: ROWS}, (_, r) => getCenterDataFaceForRow(r)));
            console.log('gridByFace:', JSON.stringify(gridByFace));
            console.log('cellState:', JSON.stringify(cellState));
            console.log('Cellules vivantes:', countAliveCells());
            console.log('Outline:', outlineEnabled ? `ON (${outlineThickness}px)` : 'OFF');
            console.log('Horizontal5:', horizontal5Enabled ? 'ON' : 'OFF');
            console.log('Last Gravity:', lastGravityAction);
        }

        // =====================================================
        // ANALYSEUR DE DIFFICULT√â
        // =====================================================
        
        /**
         * Compte les quasi-lignes (colonnes avec 4/5 cellules de m√™me couleur)
         * Plus il y en a = plus facile
         */
        function countQuasiLines() {
            let count = 0;
            
            for (let visualFace = 0; visualFace < FACES; visualFace++) {
                // Compter les couleurs dans cette colonne visuelle
                const colorCount = [0, 0, 0, 0, 0];
                let aliveCount = 0;
                
                for (let r = 0; r < ROWS; r++) {
                    const rowRotationOffset = Math.round(crownRotations[r] / ANGLE_STEP);
                    const actualDataFace = ((visualFace - rowRotationOffset) % FACES + FACES) % FACES;
                    
                    if (cellState[actualDataFace][r]) {
                        const color = gridByFace[actualDataFace][r];
                        colorCount[color]++;
                        aliveCount++;
                    }
                }
                
                // Quasi-ligne = 4 cellules de m√™me couleur sur 5
                const maxSameColor = Math.max(...colorCount);
                if (maxSameColor >= 4 && aliveCount >= 4) {
                    count++;
                }
            }
            
            return count;
        }
        
        /**
         * Compte les adjacences verticales de m√™me couleur
         * (deux cellules voisines verticalement avec m√™me couleur)
         * Plus il y en a = plus facile
         */
        function countVerticalAdjacencies() {
            let count = 0;
            
            for (let visualFace = 0; visualFace < FACES; visualFace++) {
                for (let r = 0; r < ROWS - 1; r++) {
                    const rowOffset1 = Math.round(crownRotations[r] / ANGLE_STEP);
                    const rowOffset2 = Math.round(crownRotations[r + 1] / ANGLE_STEP);
                    const face1 = ((visualFace - rowOffset1) % FACES + FACES) % FACES;
                    const face2 = ((visualFace - rowOffset2) % FACES + FACES) % FACES;
                    
                    if (cellState[face1][r] && cellState[face2][r + 1]) {
                        if (gridByFace[face1][r] === gridByFace[face2][r + 1]) {
                            count++;
                        }
                    }
                }
            }
            
            return count;
        }
        
        /**
         * Compte les paires front/back "utiles"
         * Une paire est utile si swapper am√©liorerait une quasi-ligne
         */
        function countUsefulPairs() {
            let count = 0;
            
            for (let f = 0; f < FACES / 2; f++) {
                const frontFace = f;
                const backFace = (f + 5) % FACES;
                
                for (let r = 0; r < ROWS; r++) {
                    if (!cellState[frontFace][r] || !cellState[backFace][r]) continue;
                    
                    const frontColor = gridByFace[frontFace][r];
                    const backColor = gridByFace[backFace][r];
                    
                    if (frontColor === backColor) continue; // Swap inutile
                    
                    // V√©rifier si le swap aiderait √† cr√©er une ligne
                    // Compter combien de voisins verticaux ont la couleur du back
                    let frontNeighborsMatchBack = 0;
                    let backNeighborsMatchFront = 0;
                    
                    for (let dr = -1; dr <= 1; dr += 2) {
                        const nr = r + dr;
                        if (nr < 0 || nr >= ROWS) continue;
                        
                        // V√©rifier sur la colonne front
                        const rowOffset = Math.round(crownRotations[nr] / ANGLE_STEP);
                        const neighborFace = ((frontFace + rowOffset) % FACES + FACES) % FACES;
                        
                        if (cellState[neighborFace][nr]) {
                            if (gridByFace[neighborFace][nr] === backColor) frontNeighborsMatchBack++;
                            if (gridByFace[neighborFace][nr] === frontColor) backNeighborsMatchFront++;
                        }
                    }
                    
                    // Si le swap am√©liorerait l'alignement
                    if (frontNeighborsMatchBack > 0 || backNeighborsMatchFront > 0) {
                        count++;
                    }
                }
            }
            
            return count;
        }
        
        /**
         * Mesure la dispersion des couleurs (entropie)
         * 0 = toutes les m√™mes couleurs regroup√©es
         * 100 = couleurs parfaitement dispers√©es (difficile)
         */
        function measureDispersion() {
            let totalDistance = 0;
            let pairCount = 0;
            
            // Pour chaque couleur, calculer la distance moyenne entre ses occurrences
            for (let color = 0; color < COLORS; color++) {
                const positions = [];
                
                // Trouver toutes les positions de cette couleur
                for (let f = 0; f < FACES; f++) {
                    for (let r = 0; r < ROWS; r++) {
                        if (cellState[f][r] && gridByFace[f][r] === color) {
                            positions.push({ face: f, row: r });
                        }
                    }
                }
                
                // Calculer distance entre chaque paire
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        const p1 = positions[i];
                        const p2 = positions[j];
                        
                        // Distance sur le cylindre (faces sont circulaires)
                        const faceDist = Math.min(
                            Math.abs(p1.face - p2.face),
                            FACES - Math.abs(p1.face - p2.face)
                        );
                        const rowDist = Math.abs(p1.row - p2.row);
                        
                        totalDistance += faceDist + rowDist;
                        pairCount++;
                    }
                }
            }
            
            if (pairCount === 0) return 0;
            
            const avgDistance = totalDistance / pairCount;
            // Normaliser sur 100 (distance max th√©orique ‚âà 7)
            return Math.round((avgDistance / 7) * 100);
        }
        
        /**
         * Calcule le score de difficult√© global (0-100)
         */
        function calculateDifficultyScore() {
            const quasiLines = countQuasiLines();
            const adjacencies = countVerticalAdjacencies();
            const usefulPairs = countUsefulPairs();
            const dispersion = measureDispersion();
            
            // Formule de difficult√© :
            // - Moins de quasi-lignes = plus dur
            // - Moins d'adjacences = plus dur  
            // - Moins de paires utiles = plus dur
            // - Plus de dispersion = plus dur
            
            const quasiScore = Math.max(0, 20 - quasiLines * 5);      // 0-20 points
            const adjScore = Math.max(0, 30 - adjacencies * 2);       // 0-30 points
            const pairsScore = Math.max(0, 20 - usefulPairs * 2);     // 0-20 points
            const dispersionScore = dispersion * 0.3;                  // 0-30 points
            
            const total = Math.round(quasiScore + adjScore + pairsScore + dispersionScore);
            
            return {
                quasiLines,
                adjacencies,
                usefulPairs,
                dispersion,
                score: Math.min(100, Math.max(0, total))
            };
        }
        
        /**
         * Retourne le niveau de difficult√© en texte
         */
        function getDifficultyLevel(score) {
            if (score < 20) return { text: 'üò¥ TR√àS FACILE', color: '#43e97b' };
            if (score < 40) return { text: 'üôÇ FACILE', color: '#4facfe' };
            if (score < 55) return { text: 'üòê MOYEN', color: '#fee140' };
            if (score < 70) return { text: 'üò§ DIFFICILE', color: '#fa709a' };
            if (score < 85) return { text: 'üî• TR√àS DUR', color: '#f55' };
            return { text: 'üíÄ EXTR√äME', color: '#f00' };
        }
        
        /**
         * Lance l'analyse et met √† jour l'affichage
         */
        function analyzeDifficulty() {
            const analysis = calculateDifficultyScore();
            const level = getDifficultyLevel(analysis.score);
            
            document.getElementById('dbgQuasiLines').textContent = analysis.quasiLines;
            document.getElementById('dbgAdjacent').textContent = analysis.adjacencies;
            document.getElementById('dbgUsefulPairs').textContent = analysis.usefulPairs;
            document.getElementById('dbgDispersion').textContent = analysis.dispersion + '%';
            document.getElementById('dbgDifficultyScore').textContent = analysis.score + '/100';
            document.getElementById('dbgDifficultyScore').style.color = level.color;
            document.getElementById('dbgDifficultyLevel').textContent = level.text;
            document.getElementById('dbgDifficultyLevel').style.color = level.color;
            
            console.log('=== ANALYSE DIFFICULT√â ===');
            console.log('Quasi-lignes (4/5):', analysis.quasiLines);
            console.log('Adjacences verticales:', analysis.adjacencies);
            console.log('Paires utiles:', analysis.usefulPairs);
            console.log('Dispersion:', analysis.dispersion + '%');
            console.log('SCORE:', analysis.score + '/100');
            console.log('NIVEAU:', level.text);
        }

        function testSwapAt(face, row) {
            console.log(`[TEST] Swap manuel Face ${face}, Row ${row}`);
            triggerSwap(face, row);
        }

        // =====================================================
        // VARIABLES D'INTERACTION
        // =====================================================
        let isDraggingGlobal = false;
        let isDraggingCrown = false;
        let activeCrown = -1;
        let lastX = 0;
        let lastY = 0;
        let dragStartX = 0;
        let dragStartY = 0;

        // Variables pour les zones de gravit√©
        let gravityZoneActive = null;
        let gravityStartY = 0;
        let gravityTriggered = false;

        // =====================================================
        // √âV√âNEMENTS - ZONES GRAVIT√â LAT√âRALES
        // =====================================================
        
        function setupGravityZone(element) {
            // Touch events
            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gravityStartY = e.touches[0].clientY;
                gravityTriggered = false;
                gravityZoneActive = element;
            }, { passive: false });
            
            element.addEventListener('touchmove', (e) => {
                if (gravityTriggered || gravityZoneActive !== element) return;
                e.preventDefault();
                
                const currentY = e.touches[0].clientY;
                const deltaY = currentY - gravityStartY;
                
                // Swipe vers le bas = gravit√©
                if (deltaY > INTERACTION.gravitySwipeThreshold) {
                    gravityTriggered = true;
                    element.classList.add('activated-down');
                    applyGravityDown();
                    setTimeout(() => element.classList.remove('activated-down'), 300);
                }
                // Swipe vers le haut = anti-gravit√©
                else if (deltaY < -INTERACTION.gravitySwipeThreshold) {
                    gravityTriggered = true;
                    element.classList.add('activated-up');
                    applyGravityUp();
                    setTimeout(() => element.classList.remove('activated-up'), 300);
                }
            }, { passive: false });
            
            element.addEventListener('touchend', () => {
                gravityTriggered = false;
                gravityZoneActive = null;
            });
            
            // Mouse events
            element.addEventListener('mousedown', (e) => {
                gravityStartY = e.clientY;
                gravityTriggered = false;
                gravityZoneActive = element;
            });
        }
        
        // Setup des 2 zones de gravit√© (gauche et droite)
        setupGravityZone(document.getElementById('gravityZoneLeft'));
        setupGravityZone(document.getElementById('gravityZoneRight'));
        
        // Gestion globale du mousemove pour les zones gravit√©
        document.addEventListener('mousemove', (e) => {
            if (!gravityZoneActive || gravityTriggered) return;
            
            const deltaY = e.clientY - gravityStartY;
            
            // Swipe vers le bas = gravit√©
            if (deltaY > INTERACTION.gravitySwipeThreshold) {
                gravityTriggered = true;
                gravityZoneActive.classList.add('activated-down');
                applyGravityDown();
                setTimeout(() => {
                    if (gravityZoneActive) gravityZoneActive.classList.remove('activated-down');
                }, 300);
            }
            // Swipe vers le haut = anti-gravit√©
            else if (deltaY < -INTERACTION.gravitySwipeThreshold) {
                gravityTriggered = true;
                gravityZoneActive.classList.add('activated-up');
                applyGravityUp();
                setTimeout(() => {
                    if (gravityZoneActive) gravityZoneActive.classList.remove('activated-up');
                }, 300);
            }
        });

        // =====================================================
        // √âV√âNEMENTS - SWIPE ZONE
        // =====================================================
        const swipeZone = document.getElementById('swipeZone');
        const scene = document.getElementById('scene');

        swipeZone.addEventListener('touchstart', (e) => {
            isDraggingGlobal = true;
            lastX = e.touches[0].clientX;
            setDragging(-1, true);
            currentGesture = 'drag';
            updateDebug();
        }, { passive: true });

        swipeZone.addEventListener('touchmove', (e) => {
            if (!isDraggingGlobal) return;
            const currentX = e.touches[0].clientX;
            const deltaPixels = currentX - lastX;
            const deltaDegrees = sanitizeDelta(deltaPixels);
            if (deltaDegrees !== 0) {
                globalRotation += deltaDegrees;
                updateAllRotations();
            }
            lastX = currentX;
        }, { passive: true });

        swipeZone.addEventListener('touchend', () => {
            if (isDraggingGlobal) {
                isDraggingGlobal = false;
                setDragging(-1, false);
                snapGlobal();
                currentGesture = 'idle';
                resetVelocity();
                updateDebug();
            }
        });

        swipeZone.addEventListener('mousedown', (e) => {
            isDraggingGlobal = true;
            lastX = e.clientX;
            setDragging(-1, true);
            currentGesture = 'drag';
            updateDebug();
        });

        // =====================================================
        // √âV√âNEMENTS - SCENE (Touch)
        // =====================================================
        scene.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            activeCrown = getRowFromY(touch.clientY);
            lastX = touch.clientX;
            lastY = touch.clientY;
            dragStartX = lastX;
            dragStartY = lastY;
            
            startLongPress(touch.clientX, touch.clientY);
        }, { passive: true });

        scene.addEventListener('touchmove', (e) => {
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            
            checkLongPressMove(currentX, currentY);
            
            const deltaX = currentX - dragStartX;
            const deltaY = currentY - dragStartY;
            
            // D√©tection du type de geste
            if (currentGesture === 'pending' || currentGesture === 'pending_drag_only') {
                // Swipe HORIZONTAL ‚Üí Drag couronne
                if (Math.abs(deltaX) > INTERACTION.directionThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
                    cancelLongPress();
                    currentGesture = 'drag';
                    isDraggingCrown = true;
                    if (activeCrown >= 0) setDragging(activeCrown, true);
                    updateDebug();
                }
                // Swipe VERTICAL ‚Üí Column Flip (seulement si on √©tait sur une cellule valide)
                else if (currentGesture === 'pending' && 
                         Math.abs(deltaY) > INTERACTION.verticalSwipeThreshold && 
                         Math.abs(deltaX) < INTERACTION.horizontalMaxForVertical &&
                         longPressFrozenVisualCol !== null) {
                    const visualColToFlip = longPressFrozenVisualCol; // Sauvegarder AVANT cancel
                    cancelLongPress();
                    currentGesture = 'flip';
                    triggerColumnFlip(visualColToFlip);
                    updateDebug();
                }
            }
            
            if (currentGesture === 'drag' && activeCrown >= 0) {
                const deltaPixels = currentX - lastX;
                const deltaDegrees = sanitizeDelta(deltaPixels);
                if (deltaDegrees !== 0) {
                    crownRotations[activeCrown] += deltaDegrees;
                    updateAllRotations();
                }
            }
            
            lastX = currentX;
            lastY = currentY;
        }, { passive: true });

        scene.addEventListener('touchend', () => {
            cancelLongPress();
            
            if (isDraggingCrown && activeCrown >= 0) {
                setDragging(activeCrown, false);
                snapCrown(activeCrown);
            }
            
            isDraggingCrown = false;
            activeCrown = -1;
            currentGesture = 'idle';
            resetVelocity();
            updateDebug();
        });

        // =====================================================
        // √âV√âNEMENTS - SCENE (Mouse)
        // =====================================================
        scene.addEventListener('mousedown', (e) => {
            activeCrown = getRowFromY(e.clientY);
            lastX = e.clientX;
            lastY = e.clientY;
            dragStartX = lastX;
            dragStartY = lastY;
            
            startLongPress(e.clientX, e.clientY);
        });

        document.addEventListener('mousemove', (e) => {
            checkLongPressMove(e.clientX, e.clientY);
            
            if (isDraggingGlobal) {
                const currentX = e.clientX;
                const deltaPixels = currentX - lastX;
                const deltaDegrees = sanitizeDelta(deltaPixels);
                if (deltaDegrees !== 0) {
                    globalRotation += deltaDegrees;
                    updateAllRotations();
                }
                lastX = currentX;
                return;
            }
            
            if (activeCrown < 0) return;
            
            const currentX = e.clientX;
            const currentY = e.clientY;
            const deltaX = currentX - dragStartX;
            const deltaY = currentY - dragStartY;
            
            // D√©tection du type de geste
            if (currentGesture === 'pending' || currentGesture === 'pending_drag_only') {
                // Swipe HORIZONTAL ‚Üí Drag couronne
                if (Math.abs(deltaX) > INTERACTION.directionThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
                    cancelLongPress();
                    currentGesture = 'drag';
                    isDraggingCrown = true;
                    if (activeCrown >= 0) setDragging(activeCrown, true);
                    updateDebug();
                }
                // Swipe VERTICAL ‚Üí Column Flip (seulement si on √©tait sur une cellule valide)
                else if (currentGesture === 'pending' && 
                         Math.abs(deltaY) > INTERACTION.verticalSwipeThreshold && 
                         Math.abs(deltaX) < INTERACTION.horizontalMaxForVertical &&
                         longPressFrozenVisualCol !== null) {
                    const visualColToFlip = longPressFrozenVisualCol; // Sauvegarder AVANT cancel
                    cancelLongPress();
                    currentGesture = 'flip';
                    triggerColumnFlip(visualColToFlip);
                    updateDebug();
                }
            }
            
            if (currentGesture === 'drag' && activeCrown >= 0) {
                const deltaPixels = currentX - lastX;
                const deltaDegrees = sanitizeDelta(deltaPixels);
                if (deltaDegrees !== 0) {
                    crownRotations[activeCrown] += deltaDegrees;
                    updateAllRotations();
                }
            }
            
            lastX = currentX;
            lastY = e.clientY;
        });

        document.addEventListener('mouseup', () => {
            cancelLongPress();
            gravityZoneActive = null;
            gravityTriggered = false;
            
            if (isDraggingGlobal) {
                isDraggingGlobal = false;
                setDragging(-1, false);
                snapGlobal();
            }
            if (isDraggingCrown && activeCrown >= 0) {
                setDragging(activeCrown, false);
                snapCrown(activeCrown);
            }
            
            isDraggingCrown = false;
            activeCrown = -1;
            currentGesture = 'idle';
            resetVelocity();
            updateDebug();
        });

        // =====================================================
        // √âV√âNEMENTS - MOLETTE
        // =====================================================
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            let deltaPixels = e.deltaX !== 0 ? e.deltaX : e.deltaY;
            let deltaDegrees = sanitizeDelta(deltaPixels * 0.5);
            if (deltaDegrees !== 0) {
                globalRotation += deltaDegrees;
                updateAllRotations();
            }
            clearTimeout(window.wheelTimeout);
            window.wheelTimeout = setTimeout(snapGlobal, 150);
        }, { passive: false });

        // =====================================================
        // INIT
        // =====================================================
        initGrid();
        applyPalette('neon'); // Palette par d√©faut
        buildCylinder();
        
        setTimeout(() => {
            checkVerticalLines();
            analyzeDifficulty();
        }, 100);
    </script>
</body>
</html>
