<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ADAM v3 - 40 Faces</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body {
            background-color: #12131a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        /* ========== GRILLE AVEC MASKING ========== */
        .grid-wrapper {
            position: relative;
            --cell: min(80px, 18vw);
            --half: calc(var(--cell) / 2);
            --gap: 10px;
            width: calc(4 * var(--cell) + 3 * var(--gap));
            height: calc(5 * var(--cell) + 4 * var(--gap));
            overflow: hidden; /* LE MASQUE MAGIQUE */
        }
        
        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Une face = demi-domino */
        .face {
            position: absolute;
            background-color: #12131a;
            border: 1px solid rgba(180, 180, 190, 0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            touch-action: none;
            z-index: 1;
        }
        
        .face.ghost {
            opacity: 0.9;
            pointer-events: none;
            z-index: 0;
        }
        
        /* Bords arrondis selon position */
        .face.left {
            border-radius: 14px 0 0 14px;
            border-right: none;
        }
        
        .face.right {
            border-radius: 0 14px 14px 0;
            border-left: none;
        }
        
        /* Médiane entre 2 faces d'un même domino */
        .mediane {
            position: absolute;
            width: 1px;
            background: rgba(180, 180, 190, 0.35);
            pointer-events: none;
            z-index: 2;
        }
        
        /* Zone corridor (pour détecter le drag vertical) */
        .corridor-zone {
            position: absolute;
            height: 100%;
            cursor: ns-resize;
            z-index: 100;
        }
        
        /* Icônes SVG dans les faces */
        .face svg {
            width: 90%;
            height: 90%;
        }
        
        svg line.icon,
        svg path.icon,
        svg circle.icon,
        svg rect.icon {
            stroke: rgba(180, 180, 190, 0.35);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }
        
        svg path.icon.filled {
            fill: rgba(180, 180, 190, 0.35);
            stroke: none;
        }
        
        /* === ÉTATS === */
        .face.white svg .icon { stroke: rgba(180, 180, 190, 0.35); }
        .face.white svg .icon.filled { fill: rgba(180, 180, 190, 0.35); }
        
        .face.silver svg .icon { 
            stroke: #22d3ee; 
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4));
        }
        .face.silver svg .icon.filled { 
            fill: #22d3ee; 
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4));
        }
        .face.silver {
            box-shadow: inset 0 0 15px rgba(6, 182, 212, 0.15);
            border-color: rgba(6, 182, 212, 0.4);
        }
        
        .face.gold svg .icon { 
            stroke: #ffd700; 
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
        }
        .face.gold svg .icon.filled { 
            fill: #ffd700; 
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
        }
        .face.gold {
            box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.15);
            border-color: rgba(255, 215, 0, 0.5);
        }
        
        .face.emerald svg .icon { 
            stroke: #34d399; 
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9));
        }
        .face.emerald {
            box-shadow: inset 0 0 25px rgba(52, 211, 153, 0.2);
            border-color: rgba(52, 211, 153, 0.6);
        }
        
        .face.cosmic svg .icon { 
            stroke: #c4b5fd; 
            filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7));
        }
        .face.cosmic {
            box-shadow: inset 0 0 25px rgba(131, 56, 236, 0.2);
            border-color: rgba(131, 56, 236, 0.6);
        }
        
        /* Debug info */
        .debug {
            position: fixed;
            top: 10px;
            left: 10px;
            color: rgba(180,180,190,0.5);
            font-family: monospace;
            font-size: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="debug" id="debug"></div>
    <div class="grid-wrapper" id="wrapper">
        <div class="grid-container" id="grid"></div>
    </div>
    
    <script>
        const COLS = 4;
        const ROWS = 5;
        const TOTAL_CELLS = COLS * ROWS; // 20
        const TOTAL_FACES = TOTAL_CELLS * 2; // 40
        
        const wrapper = document.getElementById('wrapper');
        const grid = document.getElementById('grid');
        const debug = document.getElementById('debug');
        
        // Dimensions calculées
        let CELL_SIZE = 80;
        let HALF_SIZE = 40;
        let GAP = 10;
        let CELL_TOTAL = 90;
        let GRID_HEIGHT = 450;
        
        function updateDimensions() {
            const vw18 = window.innerWidth * 0.18;
            CELL_SIZE = Math.min(80, vw18);
            HALF_SIZE = CELL_SIZE / 2;
            GAP = 10;
            CELL_TOTAL = CELL_SIZE + GAP;
            GRID_HEIGHT = ROWS * CELL_TOTAL;
        }
        
        // ============================================
        // ICÔNES - avec f1 (haut/gauche) et f2 (bas/droite)
        // ============================================
        const ICONS = {
            chevron: { 
                f1: '<path class="icon" d="M15 28L35 10L55 28"/>', 
                f2: '<path class="icon" d="M15 10L35 28L55 10"/>' 
            },
            triangle: { 
                f1: '<path class="icon filled" d="M35 6L55 32L15 32Z"/>', 
                f2: '<path class="icon filled" d="M35 32L55 6L15 6Z"/>' 
            },
            threeLines: { 
                f1: '<line class="icon" x1="15" y1="8" x2="15" y2="30"/><line class="icon" x1="35" y1="14" x2="35" y2="30"/><line class="icon" x1="55" y1="8" x2="55" y2="30"/>', 
                f2: '<line class="icon" x1="15" y1="8" x2="15" y2="30"/><line class="icon" x1="35" y1="8" x2="35" y2="24"/><line class="icon" x1="55" y1="8" x2="55" y2="30"/>' 
            },
            halfCircle: { 
                f1: '<path class="icon" d="M18 26 Q35 6 52 26"/>', 
                f2: '<path class="icon" d="M18 12 Q35 32 52 12"/>' 
            }
        };
        
        // ============================================
        // DONNÉES : 40 faces
        // ============================================
        // Chaque face a : icon, state, slot (0-39)
        // Slots pairs = gauche, impairs = droite
        
        let faces = [];
        let faceElements = [];
        let ghostElements = [];
        let medianeElements = [];
        
        // Preset initial (identique à l'original)
        const preset = [
            ['triangle', 'halfCircle'],   // cellule 0
            ['chevron', 'threeLines'],    // cellule 1
            ['triangle', 'chevron'],      // cellule 2
            ['halfCircle', 'threeLines'], // cellule 3
            ['chevron', 'halfCircle'],    // cellule 4
            ['triangle', 'halfCircle'],   // cellule 5
            ['chevron', 'threeLines'],    // cellule 6
            ['triangle', 'halfCircle'],   // cellule 7
            ['triangle', 'halfCircle'],   // cellule 8
            ['chevron', 'chevron'],       // cellule 9
            ['threeLines', 'threeLines'], // cellule 10
            ['chevron', 'triangle'],      // cellule 11
            ['halfCircle', 'threeLines'], // cellule 12
            ['halfCircle', 'chevron'],    // cellule 13
            ['triangle', 'threeLines'],   // cellule 14
            ['triangle', 'halfCircle'],   // cellule 15
            ['triangle', 'threeLines'],   // cellule 16
            ['halfCircle', 'threeLines'], // cellule 17
            ['chevron', 'threeLines'],    // cellule 18
            ['chevron', 'halfCircle']     // cellule 19
        ];
        
        function initFaces() {
            faces = [];
            for (let cell = 0; cell < TOTAL_CELLS; cell++) {
                // Face gauche (slot pair) - utilise f1
                faces.push({
                    icon: preset[cell][0],
                    state: 'white',
                    slot: cell * 2,
                    isF2: false
                });
                // Face droite (slot impair) - utilise f2
                faces.push({
                    icon: preset[cell][1],
                    state: 'white',
                    slot: cell * 2 + 1,
                    isF2: true
                });
            }
        }
        
        // ============================================
        // CALCUL DES POSITIONS
        // ============================================
        
        function getSlotPosition(slot) {
            const cellIndex = Math.floor(slot / 2);
            const isRight = slot % 2 === 1;
            const col = cellIndex % COLS;
            const row = Math.floor(cellIndex / COLS);
            const x = col * CELL_TOTAL + (isRight ? HALF_SIZE : 0);
            const y = row * CELL_TOTAL;
            return { x, y, col, row, isRight };
        }
        
        function getFaceBySlot(slot) {
            return faces.find(f => f.slot === slot);
        }
        
        function getFaceIndexBySlot(slot) {
            return faces.findIndex(f => f.slot === slot);
        }
        
        // ============================================
        // CRÉATION DES ÉLÉMENTS (une seule fois)
        // ============================================
        
        function createFaceElement(face, index) {
            const el = document.createElement('div');
            const pos = getSlotPosition(face.slot);
            
            el.className = `face ${pos.isRight ? 'right' : 'left'} ${face.state}`;
            el.dataset.index = index;
            
            // Utiliser f1 ou f2 selon isF2
            const svgContent = face.isF2 ? ICONS[face.icon].f2 : ICONS[face.icon].f1;
            el.innerHTML = `<svg viewBox="0 0 70 38">${svgContent}</svg>`;
            
            el.style.width = HALF_SIZE + 'px';
            el.style.height = CELL_SIZE + 'px';
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
            
            return el;
        }
        
        function createMedianeElement(cellIndex) {
            const el = document.createElement('div');
            el.className = 'mediane';
            el.dataset.cell = cellIndex;
            
            const col = cellIndex % COLS;
            const row = Math.floor(cellIndex / COLS);
            
            el.style.width = '1px';
            el.style.height = CELL_SIZE + 'px';
            el.style.left = (col * CELL_TOTAL + HALF_SIZE) + 'px';
            el.style.top = (row * CELL_TOTAL) + 'px';
            
            return el;
        }
        
        function createCorridorZone(corridorIndex) {
            const el = document.createElement('div');
            el.className = 'corridor-zone';
            el.dataset.corridor = corridorIndex;
            
            el.style.left = ((corridorIndex + 1) * CELL_TOTAL - GAP / 2 - 15) + 'px';
            el.style.width = (GAP + 30) + 'px';
            el.style.top = '0';
            
            return el;
        }
        
        function initialRender() {
            grid.innerHTML = '';
            faceElements = [];
            medianeElements = [];
            
            // Créer les 40 faces
            for (let i = 0; i < TOTAL_FACES; i++) {
                const el = createFaceElement(faces[i], i);
                grid.appendChild(el);
                faceElements.push(el);
            }
            
            // Créer les 20 médianes
            for (let cell = 0; cell < TOTAL_CELLS; cell++) {
                const el = createMedianeElement(cell);
                grid.appendChild(el);
                medianeElements.push(el);
            }
            
            // Créer les 3 zones corridor
            for (let c = 0; c < COLS - 1; c++) {
                const el = createCorridorZone(c);
                grid.appendChild(el);
            }
        }
        
        // ============================================
        // MISE À JOUR DES POSITIONS (sans recréer)
        // ============================================
        
        function updateFacePosition(faceIndex, animate = true) {
            const face = faces[faceIndex];
            const el = faceElements[faceIndex];
            if (!el) return;
            
            const pos = getSlotPosition(face.slot);
            
            if (animate) {
                el.style.transition = 'top 0.15s ease-out, left 0.15s ease-out';
            } else {
                el.style.transition = 'none';
            }
            
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
            
            // Mettre à jour la classe left/right
            el.classList.remove('left', 'right');
            el.classList.add(pos.isRight ? 'right' : 'left');
        }
        
        function updateAllPositions(animate = true) {
            for (let i = 0; i < TOTAL_FACES; i++) {
                updateFacePosition(i, animate);
            }
        }
        
        // ============================================
        // GHOSTS POUR WRAP-AROUND VERTICAL
        // ============================================
        
        function createGhostsForCorridor(corridorIndex) {
            clearGhosts();
            
            const slots = getCorridorSlots(corridorIndex);
            
            for (const slot of slots) {
                const faceIndex = getFaceIndexBySlot(slot);
                if (faceIndex < 0) continue;
                
                const face = faces[faceIndex];
                const pos = getSlotPosition(slot);
                
                // Ghost en haut
                const ghostTop = createFaceElement(face, faceIndex);
                ghostTop.classList.add('ghost');
                ghostTop.style.top = (pos.y - GRID_HEIGHT) + 'px';
                grid.appendChild(ghostTop);
                ghostElements.push({ el: ghostTop, baseY: pos.y - GRID_HEIGHT, slot });
                
                // Ghost en bas
                const ghostBottom = createFaceElement(face, faceIndex);
                ghostBottom.classList.add('ghost');
                ghostBottom.style.top = (pos.y + GRID_HEIGHT) + 'px';
                grid.appendChild(ghostBottom);
                ghostElements.push({ el: ghostBottom, baseY: pos.y + GRID_HEIGHT, slot });
            }
        }
        
        function clearGhosts() {
            ghostElements.forEach(g => g.el.remove());
            ghostElements = [];
        }
        
        // ============================================
        // ROTATION (swap 2 faces d'une même cellule)
        // ============================================
        
        function rotateDomino(cellIndex) {
            const leftSlot = cellIndex * 2;
            const rightSlot = cellIndex * 2 + 1;
            
            const leftFaceIdx = getFaceIndexBySlot(leftSlot);
            const rightFaceIdx = getFaceIndexBySlot(rightSlot);
            
            if (leftFaceIdx < 0 || rightFaceIdx < 0) return;
            
            const leftFace = faces[leftFaceIdx];
            const rightFace = faces[rightFaceIdx];
            
            // Swap les slots
            leftFace.slot = rightSlot;
            rightFace.slot = leftSlot;
            
            // Swap isF2 aussi
            leftFace.isF2 = !leftFace.isF2;
            rightFace.isF2 = !rightFace.isF2;
            
            // Mettre à jour le SVG
            const leftEl = faceElements[leftFaceIdx];
            const rightEl = faceElements[rightFaceIdx];
            leftEl.innerHTML = `<svg viewBox="0 0 70 38">${leftFace.isF2 ? ICONS[leftFace.icon].f2 : ICONS[leftFace.icon].f1}</svg>`;
            rightEl.innerHTML = `<svg viewBox="0 0 70 38">${rightFace.isF2 ? ICONS[rightFace.icon].f2 : ICONS[rightFace.icon].f1}</svg>`;
            
            // Animer les positions
            updateFacePosition(leftFaceIdx, true);
            updateFacePosition(rightFaceIdx, true);
        }
        
        // ============================================
        // CORRIDOR SLIDE
        // ============================================
        
        let isDragging = false;
        let dragCorridor = -1;
        let dragStartY = 0;
        let dragOffset = 0;
        let corridorFaceIndices = [];
        
        function getCorridorSlots(corridorIndex) {
            // Corridor N = entre col N et col N+1
            // Slots: droite de col N + gauche de col N+1
            const slots = [];
            for (let row = 0; row < ROWS; row++) {
                const leftCell = row * COLS + corridorIndex;
                const rightCell = row * COLS + corridorIndex + 1;
                slots.push(leftCell * 2 + 1);  // droite du gauche
                slots.push(rightCell * 2);      // gauche du droite
            }
            return slots;
        }
        
        function startCorridorDrag(e, corridorIndex) {
            e.preventDefault();
            isDragging = true;
            dragCorridor = corridorIndex;
            dragStartY = e.touches ? e.touches[0].clientY : e.clientY;
            dragOffset = 0;
            
            // Identifier les faces du corridor
            const slots = getCorridorSlots(corridorIndex);
            corridorFaceIndices = slots.map(s => getFaceIndexBySlot(s)).filter(i => i >= 0);
            
            // Créer les ghosts
            createGhostsForCorridor(corridorIndex);
        }
        
        function moveCorridorDrag(e) {
            if (!isDragging || dragCorridor < 0) return;
            e.preventDefault();
            
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            dragOffset = clientY - dragStartY;
            
            // Déplacer les faces du corridor
            for (const faceIdx of corridorFaceIndices) {
                const face = faces[faceIdx];
                const pos = getSlotPosition(face.slot);
                const el = faceElements[faceIdx];
                el.style.transition = 'none';
                el.style.top = (pos.y + dragOffset) + 'px';
            }
            
            // Déplacer les ghosts
            for (const ghost of ghostElements) {
                ghost.el.style.transition = 'none';
                ghost.el.style.top = (ghost.baseY + dragOffset) + 'px';
            }
        }
        
        function endCorridorDrag(e) {
            if (!isDragging || dragCorridor < 0) return;
            isDragging = false;
            
            const steps = Math.round(dragOffset / CELL_TOTAL);
            
            if (steps !== 0) {
                // Phase 1: Téléporter près de la cible
                for (const faceIdx of corridorFaceIndices) {
                    const face = faces[faceIdx];
                    const pos = getSlotPosition(face.slot);
                    const el = faceElements[faceIdx];
                    
                    const oldRow = pos.row;
                    const newRow = ((oldRow + steps) % ROWS + ROWS) % ROWS;
                    const targetY = newRow * CELL_TOTAL;
                    
                    // Normaliser pour éviter les sauts visuels
                    let currentY = pos.y + dragOffset;
                    while (currentY - targetY > GRID_HEIGHT / 2) currentY -= GRID_HEIGHT;
                    while (targetY - currentY > GRID_HEIGHT / 2) currentY += GRID_HEIGHT;
                    
                    el.style.transition = 'none';
                    el.style.top = currentY + 'px';
                }
                
                // Forcer reflow
                grid.offsetHeight;
                
                // Phase 2: Animer vers la cible
                for (const faceIdx of corridorFaceIndices) {
                    const face = faces[faceIdx];
                    const pos = getSlotPosition(face.slot);
                    const el = faceElements[faceIdx];
                    
                    const oldRow = pos.row;
                    const newRow = ((oldRow + steps) % ROWS + ROWS) % ROWS;
                    const targetY = newRow * CELL_TOTAL;
                    
                    el.style.transition = 'top 0.15s ease-out';
                    el.style.top = targetY + 'px';
                }
                
                // Appliquer le changement de données
                applyCorridorSlide(dragCorridor, steps);
                
                // Nettoyer après animation
                setTimeout(() => {
                    clearGhosts();
                    updateAllPositions(false);
                }, 200);
            } else {
                // Revenir en position
                for (const faceIdx of corridorFaceIndices) {
                    updateFacePosition(faceIdx, true);
                }
                clearGhosts();
            }
            
            dragCorridor = -1;
            corridorFaceIndices = [];
        }
        
        function applyCorridorSlide(corridorIndex, steps) {
            steps = ((steps % ROWS) + ROWS) % ROWS;
            if (steps === 0) return;
            
            const slots = getCorridorSlots(corridorIndex);
            
            // Pour chaque face du corridor, calculer son nouveau slot
            const moves = [];
            
            for (const slot of slots) {
                const faceIdx = getFaceIndexBySlot(slot);
                if (faceIdx < 0) continue;
                
                const face = faces[faceIdx];
                const cellIndex = Math.floor(slot / 2);
                const isRight = slot % 2 === 1;
                const col = cellIndex % COLS;
                const oldRow = Math.floor(cellIndex / COLS);
                
                const newRow = ((oldRow + steps) % ROWS + ROWS) % ROWS;
                const newCellIndex = newRow * COLS + col;
                const newSlot = newCellIndex * 2 + (isRight ? 1 : 0);
                
                moves.push({ faceIdx, newSlot });
            }
            
            // Appliquer tous les moves
            for (const move of moves) {
                faces[move.faceIdx].slot = move.newSlot;
            }
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        grid.addEventListener('mousedown', handleStart);
        grid.addEventListener('touchstart', handleStart, { passive: false });
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        
        function handleStart(e) {
            // Corridor ?
            const corridorZone = e.target.closest('.corridor-zone');
            if (corridorZone) {
                const c = parseInt(corridorZone.dataset.corridor);
                startCorridorDrag(e, c);
                return;
            }
            
            // Face cliquée ? → rotation du domino
            const faceEl = e.target.closest('.face');
            if (faceEl && !faceEl.classList.contains('ghost')) {
                const faceIndex = parseInt(faceEl.dataset.index);
                const face = faces[faceIndex];
                const cellIndex = Math.floor(face.slot / 2);
                rotateDomino(cellIndex);
            }
        }
        
        function handleMove(e) {
            if (isDragging && dragCorridor >= 0) {
                moveCorridorDrag(e);
            }
        }
        
        function handleEnd(e) {
            if (isDragging && dragCorridor >= 0) {
                endCorridorDrag(e);
            }
        }
        
        // ============================================
        // INIT
        // ============================================
        
        function init() {
            updateDimensions();
            initFaces();
            initialRender();
        }
        
        if (document.readyState === 'complete') {
            init();
        } else {
            window.addEventListener('load', init);
        }
        
        window.addEventListener('resize', () => {
            updateDimensions();
            updateAllPositions(false);
            // TODO: mettre à jour les médianes aussi
        });
    </script>
</body>
</html>
